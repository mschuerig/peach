import Testing
@testable import Peach

/// Tests for TrainingSession feedback state management (Story 3.3)
@Suite("TrainingSession Feedback Tests")
struct TrainingSessionFeedbackTests {

    // MARK: - Test Fixtures

    @MainActor
    func makeTrainingSession() -> (TrainingSession, MockNotePlayer, MockTrainingDataStore, MockHapticFeedbackManager) {
        let mockPlayer = MockNotePlayer()
        let mockDataStore = MockTrainingDataStore()
        let mockHaptic = MockHapticFeedbackManager()
        let profile = PerceptualProfile()
        let observers: [ComparisonObserver] = [mockDataStore, profile, mockHaptic]
        let session = TrainingSession(
            notePlayer: mockPlayer,
            observers: observers
        )
        return (session, mockPlayer, mockDataStore, mockHaptic)
    }

    // MARK: - Test Helpers

    /// Waits for the session to reach a specific state (or timeout after 1 second)
    @MainActor
    func waitForState(_ session: TrainingSession, _ expectedState: TrainingState, timeout: Duration = .seconds(1)) async throws {
        // First, yield to allow any pending async tasks to progress
        await Task.yield()

        // Check immediately after yield - with instant playback, state should be ready
        if session.state == expectedState {
            return
        }

        // If not ready yet, poll with short intervals
        let deadline = ContinuousClock.now + timeout
        while ContinuousClock.now < deadline {
            if session.state == expectedState {
                return
            }
            try await Task.sleep(for: .milliseconds(5))  // Reduced from 10ms to 5ms
            await Task.yield()  // Yield to allow state machine to progress
        }
        fatalError("Timeout waiting for state \(expectedState), current state: \(session.state)")
    }

    /// Waits for feedback to clear (showFeedback becomes false)
    @MainActor
    func waitForFeedbackToClear(_ session: TrainingSession, timeout: Duration = .seconds(1)) async throws {
        let deadline = ContinuousClock.now + timeout
        while ContinuousClock.now < deadline {
            if !session.showFeedback {
                return
            }
            try await Task.sleep(for: .milliseconds(10))
            await Task.yield()
        }
        fatalError("Timeout waiting for feedback to clear")
    }

    // MARK: - Feedback State Tests

    @MainActor
    @Test("Initial feedback state is hidden")
    func initialFeedbackState() async {
        let (session, _, _, _) = makeTrainingSession()

        #expect(session.showFeedback == false)
        #expect(session.isLastAnswerCorrect == nil)
    }

    @MainActor
    @Test("Feedback shows after correct answer")
    func feedbackShowsAfterCorrectAnswer() async throws {
        let (session, mockPlayer, _, _) = makeTrainingSession()

        // Start training
        session.startTraining()

        // Wait for awaitingAnswer state
        try await waitForState(session, .awaitingAnswer)

        // Answer correctly by checking which note was higher
        guard mockPlayer.playHistory.count >= 2 else {
            fatalError("Expected 2 notes to be played, got \(mockPlayer.playHistory.count)")
        }
        let isSecondHigher = mockPlayer.playHistory[1].frequency > mockPlayer.playHistory[0].frequency
        session.handleAnswer(isHigher: isSecondHigher)

        // Verify feedback state is set correctly
        #expect(session.showFeedback == true)
        #expect(session.isLastAnswerCorrect == true)
    }

    @MainActor
    @Test("Feedback shows after incorrect answer")
    func feedbackShowsAfterIncorrectAnswer() async throws {
        let (session, mockPlayer, _, _) = makeTrainingSession()

        // Start training
        session.startTraining()

        // Wait for awaitingAnswer state
        try await waitForState(session, .awaitingAnswer)

        // Answer incorrectly (opposite of what the comparison says)
        guard mockPlayer.playHistory.count >= 2 else {
            fatalError("Expected 2 notes to be played, got \(mockPlayer.playHistory.count)")
        }
        let isSecondHigher = mockPlayer.playHistory[1].frequency > mockPlayer.playHistory[0].frequency
        // Answer incorrectly by saying the opposite
        session.handleAnswer(isHigher: !isSecondHigher)

        // Verify feedback state is set correctly
        #expect(session.showFeedback == true)
        #expect(session.isLastAnswerCorrect == false)
    }

    @MainActor
    @Test("Feedback clears before next comparison")
    func feedbackClearsBeforeNextComparison() async throws {
        let (session, mockPlayer, _, _) = makeTrainingSession()

        // Start training
        session.startTraining()

        // Wait for awaitingAnswer state
        try await waitForState(session, .awaitingAnswer)

        // Answer (correct or incorrect doesn't matter)
        guard mockPlayer.playHistory.count >= 2 else {
            fatalError("Expected 2 notes to be played, got \(mockPlayer.playHistory.count)")
        }
        let isSecondHigher = mockPlayer.playHistory[1].frequency > mockPlayer.playHistory[0].frequency
        session.handleAnswer(isHigher: isSecondHigher)

        // Verify feedback is showing
        #expect(session.showFeedback == true)

        // Wait for feedback to clear (polls until false)
        try await waitForFeedbackToClear(session)

        // Verify feedback has cleared
        #expect(session.showFeedback == false)
    }

    // MARK: - Haptic Feedback Tests

    @MainActor
    @Test("Haptic fires on incorrect answer")
    func hapticFiresOnIncorrectAnswer() async throws {
        let (session, mockPlayer, _, mockHaptic) = makeTrainingSession()

        // Start training
        session.startTraining()

        // Wait for awaitingAnswer state
        try await waitForState(session, .awaitingAnswer)

        // Answer incorrectly
        guard mockPlayer.playHistory.count >= 2 else {
            fatalError("Expected 2 notes to be played, got \(mockPlayer.playHistory.count)")
        }
        let isSecondHigher = mockPlayer.playHistory[1].frequency > mockPlayer.playHistory[0].frequency
        session.handleAnswer(isHigher: !isSecondHigher)

        // Verify haptic was triggered
        #expect(mockHaptic.incorrectFeedbackCount == 1)
    }

    @MainActor
    @Test("Haptic does NOT fire on correct answer")
    func hapticDoesNotFireOnCorrectAnswer() async throws {
        let (session, mockPlayer, _, mockHaptic) = makeTrainingSession()

        // Start training
        session.startTraining()

        // Wait for awaitingAnswer state
        try await waitForState(session, .awaitingAnswer)

        // Answer correctly
        guard mockPlayer.playHistory.count >= 2 else {
            fatalError("Expected 2 notes to be played, got \(mockPlayer.playHistory.count)")
        }
        let isSecondHigher = mockPlayer.playHistory[1].frequency > mockPlayer.playHistory[0].frequency
        session.handleAnswer(isHigher: isSecondHigher)

        // Verify haptic was NOT triggered
        #expect(mockHaptic.incorrectFeedbackCount == 0)
    }

    @MainActor
    @Test("Feedback state clears when training stops")
    func feedbackClearsWhenTrainingStops() async throws {
        let (session, mockPlayer, _, _) = makeTrainingSession()

        // Start training
        session.startTraining()

        // Wait for awaitingAnswer state
        try await waitForState(session, .awaitingAnswer)

        // Answer to trigger feedback
        guard mockPlayer.playHistory.count >= 2 else {
            fatalError("Expected 2 notes to be played, got \(mockPlayer.playHistory.count)")
        }
        let isSecondHigher = mockPlayer.playHistory[1].frequency > mockPlayer.playHistory[0].frequency
        session.handleAnswer(isHigher: isSecondHigher)

        // Verify feedback is showing
        #expect(session.showFeedback == true)
        #expect(session.isLastAnswerCorrect != nil)

        // Stop training
        session.stop()

        // Verify feedback state is cleared
        #expect(session.showFeedback == false)
        #expect(session.isLastAnswerCorrect == nil)
    }
}
