---
commit: "c71efa7733c194eeeeb918d23b3287d89e6834ba"
date: "2026-02-27T23:23:45+01:00"
author: "Michael SchÃ¼rig <michael@schuerig.de>"
subject: "Retrospective for Epics 19 & 20: dependency management improvements"
sessions: ["5016b7a2-37a5-4e99-be61-d5b20a18cd8e"]
prev: "edd8e3c507.md"
next: "ef796db549.md"
---

[â† Previous (edd8e3c507)](edd8e3c507.md) | [Index](index.md) | [Next (ef796db549) â†’](ef796db549.md)

# Commit c71efa7733

**Date:** 2026-02-27 23:23:45 UTC+01:00  
**Author:** Michael SchÃ¼rig <michael@schuerig.de>

## Commit message

Retrospective for Epics 19 & 20: dependency management improvements

Add check-dependencies.sh to mechanically enforce import and
cross-feature coupling rules. Add Dependency Direction Rules to
project-context.md for design-level guidance. Save retrospective
document and mark both epic retrospectives done.

Co-Authored-By: Claude Opus 4.6 <noreply@anthropic.com>

## Changed files

```
.../epic-19-20-retro-2026-02-27.md                 | 102 +++++++++++++
 docs/implementation-artifacts/sprint-status.yaml   |   4 +-
 docs/project-context.md                            |  13 +-
 tools/check-dependencies.sh                        | 158 +++++++++++++++++++++
 4 files changed, 274 insertions(+), 3 deletions(-)
```

## Session `5016b7a2â€¦`

*2026-02-27 21:56:38 UTC â†’ 2026-02-27 22:23:57 UTC*

### ğŸ§‘ Human (21:56:38)

<command-message>bmad-bmm-retrospective</command-message>
<command-name>/bmad-bmm-retrospective</command-name>
<command-args>Hi Bob, I'd like to talk about epics 19 and 20. Specifically, I'd like to talk about how to help the dev agents to get better at managing dependencies in the app. Aparently, they lack a sense what a good dependency is and what a bad one is. Possibly there are mechanical ways, such as linting, to prevent some dependencies. I'm looking for suggestions. My concerns can be seen in the commits that fix code review findings. The findings concerning dependencies were mostly flagged by me, not the review agent.</command-args>

### ğŸ¤– Assistant (21:57:28)

Now let me execute the workflow. I'll start by loading the project context and sprint status to identify the epics.

### ğŸ¤– Assistant (21:57:36)

Now let me load the epic definitions and story files. I'll also look at the code review fixing commits to understand the dependency issues.

### ğŸ¤– Assistant (21:58:56)

Let me look at the specific code review fix diffs for the dependency-related stories to understand what Michael had to fix.

### ğŸ¤– Assistant (21:59:49)

Now I have a comprehensive picture. Let me proceed with the retrospective workflow. Since no previous retrospective exists, this is the first one.

---

Bob (Scrum Master): "Welcome to the retrospective, Michael. You mentioned wanting to focus specifically on Epics 19 and 20 and the dependency management problem you've been seeing with the dev agents. That's a great focused topic."

Bob (Scrum Master): "Let me check the sprint status... I can see both Epic 19 (Code Review Refactoring) and Epic 20 (Right Direction - Dependency Inversion Cleanup) are marked done. All 16 stories across both epics completed. And this is our first retrospective - no previous one to reference."

Bob (Scrum Master): "I've gone through all the story records and code review fix commits. Before I share what I found, let me set the context."

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
**TEAM RETROSPECTIVE - Epics 19 & 20: Dependency Management**
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

**EPICS SUMMARY:**

- Epic 19: 5 stories - Clean Foundations (clamping, value objects, UserSettings protocol, extract methods, TrainingSession protocol)
- Epic 20: 11 stories - Right Direction (type moves, protocol boundaries, framework isolation, injection)
- All 16 stories: done
- 16/16 "Fix code review findings" commits

Bob (Scrum Master): "Now here's the pattern I see in the data, Michael. Every single story has a 'Fix code review findings' commit. That's normal for our process. But when I look at *what* was fixed, I'm seeing a clear category that the review agent consistently missed: **dependency direction violations**."

**DEPENDENCY-RELATED FINDINGS FROM YOUR REVIEWS (not caught by review agent):**

1. **Story 20.10** (SettingsScreen injection) - The dev agent injected `TrainingDataStore` into SettingsScreen, but then SettingsScreen *still* reached into `ComparisonSession` and `PerceptualProfile` directly to orchestrate the reset. You had to refactor the entire reset flow into a closure owned by `PeachApp`, removing 3 environment dependencies from the view. The dev agent satisfied the literal AC ("inject TrainingDataStore") while creating new dependency violations.

2. **Story 20.6** (Extract @Entry from Core/) - The dev agent left `import Foundation` in `TrainingSession.swift` (a pure protocol) and used computed `var` properties where stored `let` would suffice in `PreviewUserSettings`. Small but symptomatic: the agent doesn't question whether a dependency is *needed*.

3. **Story 19.5** (TrainingSession protocol) - The dev agent left `commitResult()` as a public method on `PitchMatchingSession`, exposed a dead `adjustFrequency()` method, and kept a duplicate `centRange` constant. The slider still spoke in domain terms ("normalized") rather than being a pure UI component. You had to clean all of that up.

4. **Story 20.5** (Use protocols in profile views) - The dev agent changed the types but didn't add protocol-validation tests (you added `MockPitchDiscriminationProfile` and tests).

5. **Story 20.1** (Move types to Core/) - Pure file moves, but the dev didn't add tests to verify the types work independently in their new location.

Bob (Scrum Master): "Michael, this matches exactly what you described - the dev agents lack a sense of what a good dependency is vs. a bad one. They follow the literal instruction but don't question the dependency graph holistically."

Amelia (Developer): *looking uncomfortable* "That's fair. When I moved `TrainingDataStore` into SettingsScreen, I was focused on the AC: 'inject via environment.' I didn't step back and ask whether SettingsScreen should know about `ComparisonSession` or `PerceptualProfile` at all."

Winston (Architect): "This is a classic problem. The dev agent optimizes for 'does it compile and pass tests' rather than 'is the dependency graph clean.' Those are fundamentally different quality bars."

Bob (Scrum Master): "Michael, you said you're looking for suggestions - possibly mechanical ones like linting. Before I have the team brainstorm solutions, I want to make sure I understand the problem correctly from your perspective. What dependency violations concern you most? And do you see this as primarily a problem with the dev agent, the review agent, or both?"

### ğŸ§‘ Human (22:04:52)

First of all, we're not here to assign blame. I'm looking for ways to avoid this kind of design issues in the future and I don't like that so far we've only found them through luck. I'm hoping that there's a more reliable way. It could be some kind of linter or analysis tool. It could be more specific instructions for the review agent.

### ğŸ¤– Assistant (22:05:24)

Bob (Scrum Master): "Absolutely, Michael - no blame intended. You're right to reframe this. The question isn't 'who missed it' but 'how do we make these issues structurally impossible to miss.' Let me get the team's input on both angles: mechanical tooling and better review instructions."

Winston (Architect): "Let me break this down. There are really two categories of dependency problems we saw:"

**Category 1: Import-level violations (mechanically detectable)**
- Core/ files importing SwiftUI or UIKit
- Views importing domain internals they shouldn't know about
- Production code referencing test-only types

**Category 2: Design-level violations (requires judgment)**
- SettingsScreen orchestrating reset across 3 services instead of calling one closure
- A slider component knowing about cent ranges and frequency conversion
- Public API surface that's wider than necessary

Winston (Architect): "Category 1 is absolutely lintable. Category 2 is harder - but we can give the review agent sharper questions to ask."

Bob (Scrum Master): "Let's explore both. Winston, what tooling options exist for Swift?"

Winston (Architect): "Three approaches worth considering:"

**1. Periphery (unused code detection)**
- Finds dead code, unused imports, unnecessary public access
- Would have caught `adjustFrequency()` and the duplicate `centRange` in story 19.5
- Free, open source, Swift-native

**2. Swift Dependency Rule Enforcement via a custom script**
- A simple shell script that enforces import rules per directory
- Example rules: "files in `Core/` must not `import SwiftUI`", "files in `Core/` must not `import UIKit`", "files in feature folders must not import from other feature folders"
- Can run as a pre-commit check or in CI
- Lightweight, no external dependency (which matters given the zero-dependency policy)

**3. Xcode Build Phases / SwiftLint custom rules**
- SwiftLint is a third-party dependency, which conflicts with the project policy
- But a Build Phase script achieves the same for import-level checks without adding a package dependency

Amelia (Developer): "I'd vote for option 2 - a focused script in `tools/`. It fits our existing pattern and doesn't require any package. We could define the rules in a simple config and fail the build or pre-commit if violated."

Quinn (QA Engineer): "And it's testable. We can verify the script itself catches known violations."

Bob (Scrum Master): "For category 2 - the design-level issues - Winston, what could we add to the review agent's instructions?"

Winston (Architect): "The review agent needs a dependency checklist. Right now it checks 'does the code work' and 'does it follow style.' It doesn't systematically ask:"

**Proposed Review Agent Dependency Checklist:**

1. **For each `@Environment` / injected dependency in a view:** Does this view *need* this dependency, or is it only used to pass through to something else? If pass-through, the dependency belongs higher up (composition root).

2. **For each public method on a type:** Is this called from outside the file? If not, make it `private`. Unnecessary public surface creates accidental coupling.

3. **For each `import` statement:** Is every imported module actually used? Could a protocol replace the concrete import?

4. **The "newspaper test":** If you read just the type's public interface (protocol conformances, public/internal methods, init parameters), does it tell a coherent story about ONE responsibility? Or does it reveal knowledge of unrelated domains?

5. **The "what would break" test:** If you deleted this type, which other files would fail to compile? Are those files in the same layer or a layer above? Dependencies pointing downward or sideways are fine; dependencies pointing upward are violations.

Amelia (Developer): "That checklist would have caught the SettingsScreen issue in 20.10. Question 1 alone - 'does SettingsScreen *need* ComparisonSession?' - the answer is obviously no, it just needs a reset action."

Bob (Scrum Master): "Michael, we're looking at a two-pronged approach: a mechanical import-rule checker script for the obvious violations, and a sharpened review checklist for the design-level ones. Does this direction make sense to you? And do you have a preference for where to start?"

### ğŸ§‘ Human (22:11:45)

Yes, both prongs make sense to me. How do we go about this? Do we create a new epic for this purpose or can we handle it right now in-session?

### ğŸ¤– Assistant (22:12:03)

Bob (Scrum Master): "Good question. Let me assess the scope of each item."

Winston (Architect): "The import-rule checker is a shell script in `tools/` with a handful of rules. It's not a feature - it's infrastructure. No new Swift code, no tests to run through the full suite, no architecture changes."

Amelia (Developer): "And the review checklist is a documentation update to the review agent's instructions or `project-context.md`. Also small."

Bob (Scrum Master): "I'd say neither of these warrants a full epic. An epic is for user-facing features or significant architectural work. These are process improvements - exactly the kind of action items that come *out* of a retrospective."

Bob (Scrum Master): "Here's what I'd suggest:"

**Option A: Handle both right now, in-session**
- Write the import-rule checker script in `tools/`
- Update the review agent instructions with the dependency checklist
- Commit both as retrospective action items
- Fast, no ceremony overhead

**Option B: Create lightweight tasks (not a full epic)**
- If you'd rather review each one separately or have them go through the normal dev/review cycle
- But honestly, these are small enough to just do

Amelia (Developer): "Option A. These are tools for *us*, not product features. Let's just build them."

Quinn (QA Engineer): "Agreed. The script especially - we can validate it against the violations we already fixed in Epic 20. We know exactly what it should catch."

Bob (Scrum Master): "Michael, I'm with the team on this - both are small enough to handle right here. We'd write the import-rule checker script, run it against the current codebase to confirm it passes clean (since you already fixed everything in Epic 20), and update the review instructions. Sound good?"

### ğŸ§‘ Human (22:13:48)

We have all relevant context already present, so go ahead.

### ğŸ¤– Assistant (22:13:56)

Bob (Scrum Master): "Alright, let's get to work. Amelia, Winston - let's build both items."

Let me first understand the current directory structure to write accurate rules.

### ğŸ¤– Assistant (22:14:45)

Good. Now let me also check cross-feature imports to understand the full picture.

### ğŸ¤– Assistant (22:15:03)

Now I have everything I need. Let me create both artifacts.

### ğŸ¤– Assistant (22:15:36)

Now let me create both artifacts. I'll write the dependency checker script and update the code review instructions.

### ğŸ¤– Assistant (22:16:35)

Interesting - the script caught something real. Let me check if the Start screen references are legitimate navigation routing.

### ğŸ¤– Assistant (22:16:41)

Right - StartScreen is the navigation router. It *must* reference all screens. And `App/` (ContentView/PeachApp) similarly might reference screens. These are legitimate routing references, not dependency violations. Let me update the script to handle navigation routing properly.

### ğŸ¤– Assistant (22:17:08)

Clean pass. Now let me add the dependency review section to `project-context.md` instead of modifying the BMAD toolchain files (which Michael just confirmed should not be changed). The project context is already read by both the dev and review agents.

### ğŸ¤– Assistant (22:17:30)

Now let me update the date at the bottom of project-context.md.

### ğŸ¤– Assistant (22:17:36)

Good. Now let me verify the script still passes with the updated project-context.md (no code changes, just docs):

### ğŸ¤– Assistant (22:19:03)

Bob (Scrum Master): "Both items are done. Let me summarize what we built:"

**Prong 1: Mechanical enforcement â€” `tools/check-dependencies.sh`**

The script checks 6 rules:
1. `Core/` must not import SwiftUI, UIKit, or Charts
2. `import SwiftData` only in `Core/Data/` and `App/`
3. `import UIKit` only in `HapticFeedbackManager.swift` and `App/`
4. No `import Combine` anywhere
5. No cross-feature Screen type references (except `Start/` as the navigation router)
6. `PitchMatching/` must not reference `ComparisonFeedbackIndicator` (the specific violation from story 20.4)

It passes clean on the current codebase. It would have caught the `import SwiftUI` in Core/ files, the `import SwiftData` in SettingsScreen, and the cross-feature icon size reference â€” all things you had to fix manually.

**Prong 2: Design-level rules â€” updated `project-context.md`**

Added a "Dependency Direction Rules" section that both the dev and review agents will read. Key additions beyond what was already documented:
- **Views must not orchestrate services** â€” wrap multi-service coordination in a closure at the composition root
- **Minimize `@Environment` surface** â€” if a view only uses a dependency to pass it through, the dependency belongs higher up
- **Public API must be intentional** â€” default to `private`, not `internal`
- Points agents to run `tools/check-dependencies.sh` to verify

Bob (Scrum Master): "I didn't modify any files in `_bmad/` or `.claude/` as you requested, Michael. The rules live in `project-context.md` which both agents already read before every task. The script can be run manually or added to a pre-commit hook later."

Winston (Architect): "The script handles what's mechanically detectable. The project-context rules handle the judgment calls. Together they cover both categories we identified."

Bob (Scrum Master): "Michael, want to review the changes and then we can wrap up the retro?"

### ğŸ§‘ Human (22:21:13)

y let's wrap up the retro and save the document

### ğŸ¤– Assistant (22:21:25)

Bob (Scrum Master): "Alright team, let's bring this to a close."

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
**RETROSPECTIVE COMPLETE**
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Bob (Scrum Master): "Epics 19 & 20: Code Review Refactoring + Dependency Inversion Cleanup - REVIEWED"

**Key Takeaways:**

1. Dev agents satisfy literal acceptance criteria but don't evaluate the dependency graph holistically â€” they add dependencies without questioning whether they're needed
2. The review agent checks code quality and AC fulfillment but lacks a systematic dependency checklist â€” it doesn't ask "should this view know about this type?"
3. Both categories of dependency problems (import-level and design-level) are addressable â€” the first mechanically, the second through sharper instructions

**Action Items Delivered (in-session):**

1. `tools/check-dependencies.sh` â€” mechanical enforcement of 6 import/cross-feature rules
2. `docs/project-context.md` â€” "Dependency Direction Rules" section with design-level guidance for both dev and review agents

Bob (Scrum Master): "Good retrospective, everyone. First one in the books â€” let's make it a habit."

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Now let me save the retrospective document and update sprint status.

### ğŸ¤– Assistant (22:22:00)

Now let me update the sprint status for both retrospectives.

### ğŸ¤– Assistant (22:22:12)

Retrospective saved and sprint status updated:

- Retrospective document: `docs/implementation-artifacts/epic-19-20-retro-2026-02-27.md`
- `epic-19-retrospective`: optional â†’ done
- `epic-20-retrospective`: optional â†’ done

**Deliverables from this session:**
- `tools/check-dependencies.sh` â€” mechanical import/cross-feature rule checker (passes clean)
- `docs/project-context.md` â€” dependency direction rules for dev and review agents
- `docs/implementation-artifacts/epic-19-20-retro-2026-02-27.md` â€” retrospective record

### ğŸ§‘ Human (22:23:28)

commit this

### ğŸ¤– Assistant (22:23:57)

Committed as `c71efa7`. Working tree is clean.

---

[â† Previous (edd8e3c507)](edd8e3c507.md) | [Index](index.md) | [Next (ef796db549) â†’](ef796db549.md)
