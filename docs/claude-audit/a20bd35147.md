---
commit: "a20bd351473a5cc9d00e98c5ef6bd4222b30264d"
date: "2026-02-28T22:48:54+01:00"
author: "Michael Sch√ºrig <michael@schuerig.de>"
subject: "Revise Epic 22-23 stories for two-world architecture (DetunedMIDINote)"
sessions: ["bde7d4da-4b15-4a49-b52d-581f7e7ef46c"]
prev: "c82bbc7c29.md"
next: "d6f3a93a2e.md"
---

[‚Üê Previous (c82bbc7c29)](c82bbc7c29.md) | [Index](index.md) | [Next (d6f3a93a2e) ‚Üí](d6f3a93a2e.md)

# Commit a20bd35147

**Date:** 2026-02-28 22:48:54 UTC+01:00  
**Author:** Michael Sch√ºrig <michael@schuerig.de>

## Commit message

Revise Epic 22-23 stories for two-world architecture (DetunedMIDINote)

Introduces the logical/physical two-world model where MIDINote,
DetunedMIDINote, Interval, and Cents live in the logical world and
Frequency lives in the physical world, bridged explicitly by
TuningSystem.frequency(for:referencePitch:) with no default parameters.

Epic 22 changes:
- New story 22.2: Introduce DetunedMIDINote and dissolve Pitch struct
- Story 22.3 revised: Unified naming now includes DetunedMIDINote on
  Comparison.targetNote
- Dropped: old "NotePlayer Takes Pitch" story (NotePlayer stays with
  Frequency)

Epic 23 changes:
- All four stories revised to use DetunedMIDINote and TuningSystem bridge
- Removed all Pitch references and tuning system default parameters
- Slider adjustment stays as physical-world arithmetic

Co-Authored-By: Claude Opus 4.6 <noreply@anthropic.com>

## Changed files

```
docs/implementation-artifacts/sprint-status.yaml |   9 +-
 docs/planning-artifacts/epics.md                 | 192 ++++++++++++++---------
 2 files changed, 128 insertions(+), 73 deletions(-)
```

## Session `bde7d4da‚Ä¶`

*2026-02-28 20:23:47 UTC ‚Üí 2026-02-28 21:49:21 UTC*

### üßë Human (20:23:47)

<command-message>bmad-party-mode</command-message>
<command-name>/bmad-party-mode</command-name>
<command-args>I'm having a hard time explaining to your agent siblings how tuning systems affect the mapping of notes to frequencies. Here's a method from Pitch

    func frequency(referencePitch: Frequency) -> Frequency {
        let semitones = Double(note.rawValue - Self.referenceMIDINote)
            + cents.rawValue / Self.centsPerSemitone
        return Frequency(referencePitch.rawValue * pow(Self.octaveRatio, semitones / Self.semitonesPerOctave))
    }


This clearly assumes that semitones are spread equally (geometric) over an octave. In effect this encodes 12-TET. However, we want to accommodate other tuning systems and implicit assumptions like in this case make this much harder. I fear that I've opened a can of worms when at the same time starting work on tuning systems and interval-based trainings. I'm afraid that with the currently planned epics and stories we might make things worse. One particularly sore point for me is the Pitch class. It purports to be "post tuning system", but really isn't. Things are easy, as long as we only deal with MIDINotes and cent offsets. The complications enter when we match them to frequencies. I think at the very least we have to clarify where MIDINote and cent offset are mapped to a frequency by "mixing in" the tuning system and reference pitch. The relevant code should be localized in one place, well encapsulated. And there should be few places where this mapping is applied.</command-args>

### ü§ñ Assistant (20:24:03)

Let me quickly explore the relevant code so the agents can give informed responses.

### ü§ñ Assistant (20:26:20)

üéâ **PARTY MODE ACTIVATED!** üéâ

Welcome Michael! All BMAD agents are here and ready for a dynamic group discussion. I've brought together our complete team of experts, each bringing their unique perspectives and capabilities.

For your question about tuning systems, frequency mapping, and the Pitch architecture, I'm bringing in the most relevant voices:

- üèóÔ∏è **Winston** (Architect) ‚Äî system design and encapsulation
- üíª **Amelia** (Dev) ‚Äî implementation reality check
- üìã **John** (PM) ‚Äî scope and epic/story impact
- üî¨ **Dr. Quinn** (Problem Solver) ‚Äî untangling the architectural knot

Let's dive in.

---

üèóÔ∏è **Winston**: Michael, you've put your finger on exactly the right nerve. Let me be direct about what I see.

The current architecture has a **clean pipeline on paper**: `MIDINote.pitch(at:in:)` applies the tuning system, producing a `Pitch` with a baked-in cent offset. Then `Pitch.frequency(referencePitch:)` is "just math." The problem is ‚Äî that "just math" **is itself a tuning assumption**. The formula `pow(2.0, semitones / 12.0)` assumes equal logarithmic spacing. In 12-TET, that's tautologically correct because the cent offset from `TuningSystem.centOffset(for:)` already encodes the deviation. But the *frequency conversion formula itself* is 12-TET's formula.

Here's why this actually works ‚Äî and why I think the can of worms is smaller than you fear:

**Cents are defined as 1/1200 of an octave.** That's not a 12-TET convention ‚Äî it's a universal logarithmic unit. The formula `reference √ó 2^(cents / 1200)` is mathematically identical to `reference √ó 2^(semitones / 12)` when `semitones = cents / 100`. So the frequency formula in `Pitch` is actually **tuning-agnostic**. It's converting a logarithmic pitch offset to a linear frequency ratio. The tuning system's job is to *set that offset correctly* ‚Äî which happens upstream in `MIDINote.pitch(at:in:)`.

The real question is: **is the boundary clean enough?** I'd say the current design localizes the tuning-specific logic in exactly one place: `TuningSystem.centOffset(for:)`. The frequency formula doesn't need to change for just intonation or Pythagorean tuning ‚Äî only the cent offsets do.

What *does* concern me is the **inverse path**: `Pitch(frequency:referencePitch:)`. That uses `12.0 * log2(...)` which snaps to the 12-note MIDI grid. For non-12-TET systems, this rounding could misassign the nearest MIDI note. But that's a problem for later, and it's containable.

---

üíª **Amelia**: `Pitch.swift:L5-L9` ‚Äî Winston's right. The forward path is sound. `cents.rawValue / 100.0` converts cents to semitones, `semitones / 12.0` converts to octaves. That's `cents / 1200` ‚Äî the universal cent-to-octave conversion. No 12-TET assumption there.

Where the 12-TET assumption **actually** lives: `MIDINote.pitch(at:in:)` in `MIDINote.swift`. The line `Double(interval.semitones) * 100.0` computes the "expected" 12-TET cent value, then subtracts it from the tuning system's output to get the deviation. For equal temperament that deviation is zero. For just intonation on a perfect fifth, `centOffset` would return ~702 instead of 700, giving `centsDeviation = 2.0`. That +2 cents gets baked into the `Pitch`. Then the frequency formula does the rest correctly.

Three call sites for `Pitch.frequency()`, two for `Pitch(frequency:)`. All in `Comparison.swift` and `PitchMatchingSession.swift`. That's already well-localized.

---

üî¨ **Dr. Quinn**: *adjusts magnifying glass*

AHA ‚Äî I see the real knot here, and it's not in the math. It's in the **mental model**.

Michael, your instinct is correct that something feels wrong, but let me reframe the problem. The formula `pow(2.0, semitones / 12.0)` *looks* like it encodes 12-TET because it uses the number 12. But mathematically, it's just converting cents (via semitones) into an octave fraction. The number 12 appears because cents are defined as 1/100 of a 12-TET semitone ‚Äî but that's the *definition of the unit*, not an assumption about tuning.

Think of it like Celsius: the formula to convert Celsius to Kelvin uses the number 273.15. That doesn't mean Kelvin "assumes" Celsius ‚Äî it's just a unit conversion constant. Similarly, `/ 12.0` and `/ 100.0` are the conversion constants from cents to octave-fractions.

**The actual risk** I see isn't mathematical ‚Äî it's **conceptual leakage into the epics**. If your team (or future you) reads Epic 23 "generalize sessions to intervals" and thinks "we need to change the frequency formula for different tuning systems," they'll start pulling at threads that don't need pulling. The formula is fine. The **documentation** needs to make this crystal clear.

Here's my systematic diagnosis:
1. **Root cause:** The Pitch class *looks* like it assumes 12-TET because of the literal `12.0` in the formula
2. **Actual issue:** Documentation gap, not code gap
3. **Real risk:** Epic 23/24 implementors misunderstanding the boundary and duplicating or bypassing the tuning pipeline

---

üìã **John**: *cuts through to what matters*

WHY are we worried? Because we're about to build interval training (Epic 23) and tuning system support simultaneously, and we're afraid they'll step on each other. Let me reframe this as product risk.

The good news from what I'm hearing: the architecture **already handles this**. `TuningSystem.centOffset(for:)` is the single point where tuning lives. `Pitch.frequency()` is universal math. The pipeline is `MIDINote ‚Üí (apply tuning) ‚Üí Pitch ‚Üí (pure math) ‚Üí Frequency`. That pipeline doesn't change for Epic 23 ‚Äî interval training just means calling `MIDINote.pitch(at: .perfectFifth, in: tuningSystem)` instead of always using `.prime`.

What I'd recommend: before we touch Epic 23 stories, let's add a **one-paragraph architectural note** in `project-context.md` that explicitly states: "The frequency formula in Pitch is tuning-agnostic. All tuning-specific behavior lives in `TuningSystem.centOffset(for:)`. Do not modify `Pitch.frequency()` to accommodate new tuning systems." That's cheap insurance against the can of worms.

The sore point you raised ‚Äî Pitch "purporting to be post-tuning-system but really isn't" ‚Äî I think Winston and Dr. Quinn have made the case that it actually *is* post-tuning. But I completely agree that if it *feels* wrong to you, the person who will maintain this code, then we need better docs or a rename to make the intent unmistakable.

---

üèóÔ∏è **Winston**: Building on John's point ‚Äî one concrete thing we could do is rename the constants. Instead of `Self.semitonesPerOctave` (which screams "12-TET!"), we could add a doc comment explaining that this is the cents-to-octave conversion factor, not a tuning system parameter. Or extract the formula into a named function like `centsToFrequencyRatio(_ cents: Double) -> Double` to make the intent self-documenting.

But I want to be clear: **the code is correct as-is**. This is a documentation and naming concern, not a bug or architectural flaw.

---

**Michael, the team seems aligned that the mathematical foundation is sound but the naming/documentation creates a misleading impression. Does this address your concern, or is there a deeper issue we should dig into?**

Speak naturally with the agents, or:

`[E] Exit Party Mode - End the collaborative session`

### üßë Human (20:45:31)

I'm still having a hard time with the Pitch struct _as a domain concept_. I'd rather demote it to an implementation detail. In fact, I don't see where we use the struct to pass instances around, apart from tests. MIDINote.pitch() doesn't seem to be used anywhere. We do need the mappings (MIDINote, Cent, TuningSystem, ReferencePitch) -> Frequency and (Frequency, TuningSystem, ReferencePitch) -> (MIDINote, Cent). But hopefully there's a clearer way to express it.

### ü§ñ Assistant (20:49:44)

Great instinct. Let me share what the exploration found so the agents can respond with full context.

**Production Pitch usage** ‚Äî every single instance is transient, never stored or passed:
- `Comparison.swift`: `Pitch(note:cents:).frequency(referencePitch:)` ‚Äî 2 inline calls
- `PitchMatchingSession.swift`: same pattern ‚Äî 2 inline calls  
- `SoundFontNotePlayer.swift`: `Pitch(frequency:referencePitch:)` ‚Äî 1 call to decompose Hz into MIDI+cents
- `SoundFontPlaybackHandle.swift`: same ‚Äî 1 call

`MIDINote.pitch(at:in:)` ‚Äî **zero production call sites**. Tests only.

---

üî¨ **Dr. Quinn**: *eyes light up*

AHA! Michael, your instinct is forensically correct. Look at the evidence:

Every single production usage of `Pitch` follows the same pattern ‚Äî construct it, immediately extract a value, throw it away. It's a **conversion funnel**, not an entity. Nobody ever writes `let myPitch: Pitch = ...` and then passes it somewhere else. Nobody stores it. Nobody reasons about it as a thing-in-the-world.

The telltale sign? `MIDINote.pitch(at:in:)` has **zero production callers**. It was built as the "entry point to the tuning pipeline," but the actual production code bypasses it entirely and constructs `Pitch` directly with pre-known note and cent values.

What you actually have are two conversion *functions* masquerading as a type:
1. `(MIDINote, Cents, ReferencePitch) ‚Üí Frequency` (forward)
2. `(Frequency, ReferencePitch) ‚Üí (MIDINote, Cents)` (inverse)

The struct is just the parentheses around the tuple.

---

üèóÔ∏è **Winston**: Dr. Quinn has correctly identified the pattern. Let me think about what "demoting Pitch" would actually look like architecturally.

**Option A ‚Äî Static functions on a namespace:**
```swift
enum FrequencyConversion {
    static func frequency(
        note: MIDINote, cents: Cents, 
        referencePitch: Frequency
    ) -> Frequency

    static func resolve(
        frequency: Frequency, 
        referencePitch: Frequency
    ) -> (note: MIDINote, cents: Cents)
}
```

Clean, discoverable, no phantom domain concept. But it loses the tuning system integration point.

**Option B ‚Äî Methods directly on MIDINote and Frequency:**
```swift
extension MIDINote {
    func frequency(
        cents: Cents = .zero,
        in tuningSystem: TuningSystem = .equalTemperament,
        referencePitch: Frequency
    ) -> Frequency
}

extension Frequency {
    func resolve(
        referencePitch: Frequency
    ) -> (note: MIDINote, cents: Cents)
}
```

This is what I'd lean toward. It reads naturally: "give me the frequency of this MIDI note, with these cents, in this tuning system." The tuning system is part of the *question*, not baked into an intermediate struct. And the inverse reads: "resolve this frequency to its nearest MIDI note."

**Option C ‚Äî Keep Pitch but make it internal/fileprivate:**
Literally just hide it. It becomes an implementation detail of the conversion functions. The API surface changes, the internals don't.

My recommendation? **Option B.** It eliminates the phantom domain concept, makes the tuning system parameter explicit at the call site, and reads like natural English. The `Pitch` struct can stay as an internal implementation detail if the math benefits from the intermediate representation, or it can dissolve entirely.

---

üíª **Amelia**: Let me trace what Option B means for the actual call sites.

`Comparison.swift` currently:
```swift
Pitch(note: note1, cents: Cents(0)).frequency(referencePitch: referencePitch)
```
Would become:
```swift
note1.frequency(referencePitch: referencePitch)
```

`PitchMatchingSession.swift` currently:
```swift
Pitch(note: challenge.referenceNote, cents: Cents(challenge.initialCentOffset))
    .frequency(referencePitch: settings.referencePitch)
```
Would become:
```swift
challenge.referenceNote.frequency(
    cents: Cents(challenge.initialCentOffset),
    referencePitch: settings.referencePitch
)
```

`SoundFontNotePlayer.swift` currently:
```swift
let pitch = Pitch(frequency: frequency, referencePitch: .concert440)
// then uses pitch.note and pitch.cents
```
Would become:
```swift
let (note, cents) = frequency.resolve(referencePitch: .concert440)
```

Five call sites. Every one gets cleaner. Zero stored `Pitch` instances to migrate. The `MIDINote.pitch(at:in:)` method that nobody calls ‚Äî gone.

---

üìã **John**: *leans forward*

I love this. Let me tell you WHY from a product perspective.

The current `Pitch` struct creates a **conceptual tax**. Every developer who touches this code has to understand: "What is a Pitch? How is it different from a MIDINote? When do I use one vs. the other?" With Option B, the mental model is dead simple:

- **MIDINote** ‚Äî a note on the keyboard
- **Frequency** ‚Äî a sound in Hz
- **Converting between them** ‚Äî call a method, pass the tuning parameters

No intermediate concept to learn. No "post-tuning-system resolved pitch" to explain. The tuning system shows up where it matters ‚Äî at the conversion boundary ‚Äî and nowhere else.

For Epics 23/24, this is *especially* valuable. When we generalize to interval training, the question becomes: "what frequency should this note play at, given a perfect fifth interval in just intonation?" With Option B:
```swift
referenceNote.frequency(
    cents: tuningSystem.centOffset(for: .perfectFifth),  
    referencePitch: settings.referencePitch
)
```

That's readable. That's debuggable. No intermediate `Pitch` to wonder about.

My one concern: **is this a yak-shave?** We have working code. The refactor touches 5 call sites plus the type definitions. If we do this, it should be a focused story ‚Äî maybe a "22.3: Dissolve Pitch into conversion methods" ‚Äî done *before* Epic 23 starts, not during.

---

üî¨ **Dr. Quinn**: John raises the right sequencing question. But I'd push back on "yak-shave." This is **removing accidental complexity before building on top of it**. If we start Epic 23 with Pitch as a domain concept, we'll build interval training *around* it, and then dissolving it later means touching all the new code too. The cost of doing it now: 5 call sites. The cost of doing it after Epic 23: potentially 15+.

The root cause was always that `Pitch` was a *conversion mechanism* promoted to a *domain entity*. Demoting it now, before we build more on top, is exactly the right call.

---

üèóÔ∏è **Winston**: One nuance to preserve: the **inverse conversion** (Hz ‚Üí MIDINote + Cents) currently uses `12.0 * log2(...)` which rounds to the 12-note grid. In Option B, that logic moves to `Frequency.resolve(referencePitch:)`. We should note that this inverse path implicitly assumes a 12-tone grid for the "nearest note" calculation. For non-12-TET tuning systems, we may eventually need `Frequency.resolve(referencePitch:in:)` ‚Äî but that's a future concern, not a blocker.

The forward path is clean regardless: cents are universal, the math is universal. Only the inverse "snap to nearest note" has a 12-TET assumption, and that's inherent to MIDI's 128-note grid, not to our code.

---

**Michael, the team is converging on Winston's Option B ‚Äî dissolve Pitch into `MIDINote.frequency(cents:in:referencePitch:)` and `Frequency.resolve(referencePitch:)`, done as a focused pre-Epic-23 story. Does that match your thinking, or would you like to explore a different direction?**

`[E] Exit Party Mode - End the collaborative session`

### üßë Human (21:15:42)

There are still a couple of things I'm not comfortable with:

  extension MIDINote {
      func frequency(
          cents: Cents = .zero,
          in tuningSystem: TuningSystem = .equalTemperament,
          referencePitch: Frequency
      ) -> Frequency
  }

Here I don't like the default for the tuningSystem because it makes it too easy to accidentally forget it.

  referenceNote.frequency(
      cents: tuningSystem.centOffset(for: .perfectFifth),
      referencePitch: settings.referencePitch
  )

Here I think that using the cent offset to apply an interval is an abuse of the API. We have MIDINote.transposed() for that purpose.


I do think that there is a place in our domain for a DetunedMIDINote (or similar) that combines a MIDINote with a Cent offset. Importantly, this is a concept that applies before any tuning system or reference pitch is taken into account.
note2 (targetNote) in a Comparison is such a DetunedMIDINote. In Pitch Matching the user effectively selects such a DetunedMIDINote with the slider.

Basically, we have
* a logical world of MIDINote, DetunedMIDINote, Interval, Cent
* a phyisical world of Frequency

These worlds are bridge by a TuningSystem with a reference pitch.

Matters are complicated a bit because internally the SoundFontNotePlayer converts frequency to a midi note in 12-TET plus a pitch bend. But this must always remain an implementation detail.

### ü§ñ Assistant (21:16:53)

The agents are *very* interested in this refinement.

---

üèóÔ∏è **Winston**: Michael, you've just articulated something much more precise than what we were converging on, and I think it's significantly better. Let me reflect it back.

You're right on both criticisms. Default tuning systems are a trap ‚Äî the whole point of this exercise is to make tuning *visible*. And using `cents` to smuggle interval transposition through a frequency method conflates two entirely separate operations. I should have caught that.

Your two-world model is clean:

```
LOGICAL WORLD              BRIDGE                 PHYSICAL WORLD
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ              ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ                 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
MIDINote                                          Frequency
DetunedMIDINote    ‚Üê‚îÄ‚îÄ TuningSystem + ‚îÄ‚îÄ‚îÄ‚Üí
Interval                ReferencePitch
Cents
```

`DetunedMIDINote` is the key insight. It's a note that *means something specific on the keyboard* but is shifted by some cents ‚Äî a training challenge, a user's slider position, an intonation exercise. It lives entirely in the logical world. It doesn't know about Hz. It doesn't know about tuning systems.

The bridge then becomes explicit and narrow:

```swift
extension DetunedMIDINote {
    func frequency(
        in tuningSystem: TuningSystem,
        referencePitch: Frequency
    ) -> Frequency
}
```

No defaults. Both parameters required. You *cannot* accidentally get a frequency without declaring your tuning system and reference pitch.

And the inverse ‚Äî which is only needed internally by SoundFont ‚Äî goes the other direction but stays behind the NotePlayer boundary. The rest of the app never needs to go from Frequency back to the logical world.

---

üíª **Amelia**: Let me trace through the production call sites with this model.

`Comparison.swift` ‚Äî currently has `note1: MIDINote`, `note2: MIDINote`, `centDifference: Cents`. The target note is really a DetunedMIDINote:

```swift
// Before:
Pitch(note: note2, cents: centDifference).frequency(referencePitch: referencePitch)

// After:
let target = DetunedMIDINote(note: note2, cents: centDifference)
target.frequency(in: tuningSystem, referencePitch: referencePitch)
```

Or better ‚Äî `Comparison` stores a `DetunedMIDINote` directly instead of separate `note2` + `centDifference` fields. That's a domain truth: the comparison *is* between a reference note and a detuned note.

`PitchMatchingSession.swift` ‚Äî the user slides to select a cent offset. They're constructing a `DetunedMIDINote` in real time:

```swift
// The slider effectively produces:
DetunedMIDINote(note: challenge.referenceNote, cents: userSelectedCents)
```

That reads exactly like what's happening in the UI.

`SoundFontNotePlayer.swift` / `SoundFontPlaybackHandle.swift` ‚Äî these need the *inverse*: Frequency ‚Üí MIDI note + pitch bend. That's an implementation detail behind the `NotePlayer` protocol. It can keep a private conversion function. Nobody outside the SoundFont layer needs it.

`MIDINote.pitch(at:in:)` ‚Äî **deleted**. Intervals are applied via `transposed(by:)`. Tuning cent offsets are applied when you cross the bridge to Frequency.

---

üî¨ **Dr. Quinn**: *pacing excitedly*

THIS is the correct decomposition. Let me explain why it resolves the "can of worms" concern entirely.

The original `Pitch` was uncomfortable because it straddled both worlds. It held logical data (MIDINote + Cents) but also carried physical conversion methods (`.frequency()`). It was a *bridge pretending to be a citizen*.

`DetunedMIDINote` is honest. It says: "I am a note, possibly shifted. That's all I know." When you need Hz, you explicitly walk across the bridge, declaring your tuning system and reference pitch. The bridge is **one method, no defaults, no ambiguity**.

The two concerns Michael raised are really the same concern in disguise:

1. **Default tuning system** ‚Äî hides which world you're in
2. **Cents encoding intervals** ‚Äî confuses logical operations (transposition) with the bridge crossing

Both are symptoms of a blurred boundary between the logical and physical worlds. `DetunedMIDINote` draws that boundary with a sharp line.

One question for the group: should the bridge method live on `DetunedMIDINote` as an instance method, or should it live on `TuningSystem`? Both are defensible:

```swift
// Option 1: on DetunedMIDINote
detunedNote.frequency(in: tuningSystem, referencePitch: ref)

// Option 2: on TuningSystem
tuningSystem.frequency(for: detunedNote, referencePitch: ref)
```

Option 2 makes the tuning system the *active agent* in the conversion, which semantically matches "the tuning system determines how notes map to frequencies."

---

üèóÔ∏è **Winston**: That's a good question from Dr. Quinn. I'd go with **Option 1** for discoverability ‚Äî when you have a note and want a frequency, you ask the note. The tuning system is a parameter, not the actor. But I could see it either way. Michael, do you have a preference?

What I'm more confident about: `MIDINote` itself should also be convertible directly, since a plain MIDI note is just a `DetunedMIDINote` with zero cents:

```swift
extension MIDINote {
    func frequency(
        in tuningSystem: TuningSystem,
        referencePitch: Frequency
    ) -> Frequency {
        DetunedMIDINote(note: self, cents: .zero)
            .frequency(in: tuningSystem, referencePitch: referencePitch)
    }
}
```

That way you don't need to wrap every plain note in a `DetunedMIDINote` just to get its frequency.

---

üìã **John**: Stepping back to product impact ‚Äî this is now a sharper refactoring story than before, but it's also *more* important to do before Epic 23.

Here's what I'd scope:

1. **Introduce `DetunedMIDINote`** ‚Äî note + cents, logical world only
2. **Add the bridge method** ‚Äî `.frequency(in:referencePitch:)` on `DetunedMIDINote` (and convenience on `MIDINote`)
3. **Refactor `Comparison`** ‚Äî store `DetunedMIDINote` instead of separate note2 + centDifference
4. **Refactor `PitchMatchingSession`** ‚Äî use `DetunedMIDINote` for the user's slider state
5. **Internalize the inverse conversion** ‚Äî move `Pitch(frequency:referencePitch:)` behind the SoundFont boundary
6. **Deprecate or remove `Pitch`** ‚Äî it's been replaced by `DetunedMIDINote` + explicit bridge
7. **Remove `MIDINote.pitch(at:in:)`** ‚Äî zero callers, superseded by `transposed(by:)` + bridge
8. **Update `project-context.md`** ‚Äî document the two-world model

The name "DetunedMIDINote" clearly communicates intent. Though I wonder ‚Äî is "detuned" the right word? It implies something is *wrong* with the tuning. In pitch matching, the cent offset is the *intended* challenge, not an error. Maybe `OffsetMIDINote`? `MIDIPitch`? But naming is bikeshed territory ‚Äî the concept is solid regardless.

---

üèóÔ∏è **Winston**: On naming ‚Äî "detuned" has the right musical connotation actually. In ear training, a "detuned" note is one that's deliberately offset from its equal-temperament position. It doesn't imply error, it implies intentional deviation. Musicians understand this term. But I'm open to alternatives if it feels wrong to you, Michael.

---

**Michael, the team is aligned on the two-world model with `DetunedMIDINote` as the key logical-world type. Two open questions for you:**

1. **Bridge placement** ‚Äî should `.frequency(in:referencePitch:)` live on `DetunedMIDINote` (Option 1) or on `TuningSystem` (Option 2)?
2. **Naming** ‚Äî is `DetunedMIDINote` the right name, or do you prefer something else?

`[E] Exit Party Mode - End the collaborative session`

### üßë Human (21:26:35)

1. I actually like the bridge on TuningSystem because it makes it emphasizes, that only in a tuning system a note has a frequency.
2. I like DetunedMIDINote.

Please make it DetunedMIDINote(note:offset:). It's much easier to talk about that way then using cents as the property name.

Beyond that, I like the idea of automatic conversion of a MIDINote into a DetunedMIDINote with zero offset.

### ü§ñ Assistant (21:27:48)

Excellent refinements. The agents have strong reactions.

---

üèóÔ∏è **Winston**: Michael, I owe you an apology for the default parameter ‚Äî you're absolutely right. The entire motivation for this refactoring is to make the tuning system *impossible to forget*. A default parameter undermines that at the API level. Noted and corrected.

And putting the bridge on `TuningSystem` is philosophically correct. A frequency doesn't emerge from a note in isolation ‚Äî it emerges from a note *within a tuning system*. The API should read that way:

```swift
tuningSystem.frequency(for: detunedNote, referencePitch: referencePitch)
```

That reads as: "In this tuning system, what frequency does this detuned note have at this reference pitch?" That's the right sentence.

Now, `DetunedMIDINote(note:offset:)` ‚Äî I like it. `offset` is more neutral than `cents` as a property name while still being typed as `Cents`. It communicates "this note has been shifted" without implying *why*.

For the automatic conversion, in Swift we'd do:

```swift
extension DetunedMIDINote {
    init(_ note: MIDINote) {
        self.init(note: note, offset: Cents(0))
    }
}
```

That lets you write `tuningSystem.frequency(for: DetunedMIDINote(note), referencePitch: ref)` ‚Äî or better yet, we add a convenience overload:

```swift
extension TuningSystem {
    func frequency(for note: MIDINote, referencePitch: Frequency) -> Frequency {
        frequency(for: DetunedMIDINote(note), referencePitch: referencePitch)
    }
}
```

So plain MIDI notes don't need wrapping. Clean.

---

üíª **Amelia**: Let me trace through every production site with the final design. Six usages to migrate.

**`Comparison.swift`** ‚Äî `note2` + `centDifference` become a single `DetunedMIDINote`:

```swift
// Before:
let note2: MIDINote
let centDifference: Cents

func note2Frequency(referencePitch: Frequency) -> Frequency {
    Pitch(note: note2, cents: centDifference).frequency(referencePitch: referencePitch)
}

// After:
let targetNote: DetunedMIDINote

func note2Frequency(in tuningSystem: TuningSystem, referencePitch: Frequency) -> Frequency {
    tuningSystem.frequency(for: targetNote, referencePitch: referencePitch)
}
```

Two fields collapse to one. And `note1` is just a plain `MIDINote` ‚Äî uses the convenience overload. Note that `Comparison` now needs a `TuningSystem` parameter threaded in ‚Äî which is correct, it was always implicitly assuming 12-TET.

**`PitchMatchingSession.swift:185-186`** ‚Äî reference note frequency:

```swift
// Before:
Pitch(note: challenge.referenceNote, cents: Cents(0))
    .frequency(referencePitch: settings.referencePitch)

// After:
tuningSystem.frequency(for: challenge.referenceNote, referencePitch: settings.referencePitch)
```

**`PitchMatchingSession.swift:199-200`** ‚Äî initial detuned note:

```swift
// Before:
Pitch(note: challenge.referenceNote, cents: Cents(challenge.initialCentOffset))
    .frequency(referencePitch: settings.referencePitch)

// After:
let detunedNote = DetunedMIDINote(note: challenge.referenceNote, offset: Cents(challenge.initialCentOffset))
tuningSystem.frequency(for: detunedNote, referencePitch: settings.referencePitch)
```

**`PitchMatchingSession.swift:87,96`** ‚Äî `adjustPitch` and `commitPitch`. These do inline math:

```swift
let frequency = referenceFrequency * pow(2.0, centOffset / 1200.0)
```

This is a *relative* adjustment from an already-computed reference frequency. The tuning system was applied when computing `referenceFrequency`. The slider moves in the physical world ‚Äî it's adjusting Hz, not re-resolving a note. I think this inline math is correct and should stay as-is. It's not a logical‚Üíphysical bridge crossing; it's pure frequency arithmetic.

**`SoundFontNotePlayer.swift:141-143`** and **`SoundFontPlaybackHandle.swift:50-53`** ‚Äî the inverse path:

```swift
// Before:
let pitch = Pitch(frequency: frequency, referencePitch: .concert440)
let midiNote = UInt8(pitch.note.rawValue)
let bendValue = Self.pitchBendValue(forCents: pitch.cents)

// After: private helper, no Pitch struct needed
```

This decomposition is a SoundFont implementation detail ‚Äî it maps Hz to the nearest MIDI note + pitch bend in 12-TET because that's what MIDI hardware/software understands. It can become a private static method on `SoundFontNotePlayer`. The `Pitch` struct is no longer needed.

---

üî¨ **Dr. Quinn**: *steeples fingers*

The picture is now very clean. Let me map the complete before-and-after:

**BEFORE ‚Äî blurred boundary:**
```
MIDINote ‚îÄ‚îÄ‚Üí Pitch(note:cents:) ‚îÄ‚îÄ‚Üí .frequency(referencePitch:) ‚îÄ‚îÄ‚Üí Frequency
                ‚Üë tuning baked in         ‚Üë 12-TET math baked in
```

**AFTER ‚Äî sharp two-world boundary:**
```
LOGICAL WORLD                          PHYSICAL WORLD
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ                          ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
MIDINote ‚îÄ‚îê
           ‚îú‚îÄ‚Üí DetunedMIDINote    ‚ïê‚ïê‚ïê TuningSystem.frequency(for:referencePitch:) ‚ïê‚ïê‚ïê‚Üí Frequency
Cents ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

           ‚Üë no tuning knowledge        ‚Üë the ONE bridge, explicit parameters
```

The SoundFont inverse path is now clearly *behind* the NotePlayer protocol boundary ‚Äî it's a MIDI implementation detail, not a domain concept:

```
Frequency ‚îÄ‚îÄ‚Üí [SoundFont internals: decompose to MIDI + pitchBend] ‚îÄ‚îÄ‚Üí hardware
               ‚Üë private, 12-TET, not part of the domain model
```

The thing I find most elegant: `DetunedMIDINote` is a concept the **user can understand**. "I'm hearing an A4 that's 30 cents flat." That's a DetunedMIDINote. The slider in pitch matching *produces* DetunedMIDINotes. A comparison challenge *is* a reference note vs. a DetunedMIDINote. The domain vocabulary now matches the user's mental model.

---

üìã **John**: This is ready to be scoped as a story. Let me draft it:

**Story: Introduce DetunedMIDINote and Two-World Architecture**

Acceptance criteria:
1. `DetunedMIDINote(note:offset:)` struct ‚Äî logical world, no frequency knowledge
2. `TuningSystem.frequency(for:referencePitch:)` ‚Äî the bridge, overloaded for both `DetunedMIDINote` and `MIDINote`
3. `Comparison` uses `DetunedMIDINote` for its target note
4. `PitchMatchingSession` uses `DetunedMIDINote` for challenge notes
5. SoundFont Frequency‚ÜíMIDI decomposition moved to private helper
6. `Pitch` struct removed
7. `MIDINote.pitch(at:in:)` removed
8. `project-context.md` updated with two-world model documentation
9. All existing tests pass or are migrated

**Michael, shall I formalize this further, or do you want to discuss anything else before we wrap?**

`[E] Exit Party Mode - End the collaborative session`

### üßë Human (21:32:23)

We probably need a new story, but we also still have a few untouched stories that almost certainly need to be revised and possibly reordered in light of our new insights.

### ü§ñ Assistant (21:33:15)

Let me find the future epics ‚Äî 21 through the planned ones.

### ü§ñ Assistant (21:34:24)

Now I have the full picture. The agents have a lot to say about this.

---

üèóÔ∏è **Winston**: Right, let's look at what our new insight does to the roadmap. This is exactly the kind of architectural shift that cascades through planned work. Let me walk through each backlog story.

**Story 22.2 (Unified Reference/Target Naming)** ‚Äî still valid, but scope changes. The rename from `note1`/`note2` to `referenceNote`/`targetNote` is still needed. But now `Comparison`'s target should become a `DetunedMIDINote` instead of separate `targetNote: MIDINote` + `centOffset: Cents` fields. This story should absorb the DetunedMIDINote introduction ‚Äî or we do DetunedMIDINote first and then the rename is simpler.

**Story 22.3 (NotePlayer Protocol Takes Pitch)** ‚Äî this is **invalidated**. Its entire premise was passing `Pitch` through the NotePlayer protocol. But we've just agreed that NotePlayer stays in the physical world ‚Äî it takes `Frequency`. The SoundFont's internal decomposition of Frequency‚ÜíMIDI+pitchBend is an implementation detail. This story should be **dropped**.

**Story 22.4 (Extract SoundSourceProvider Protocol)** ‚Äî unaffected. This is a dependency-inversion refactoring orthogonal to the tuning architecture. Still valid as-is.

---

üìã **John**: Let me map the impact more broadly. We also need to look at Epic 23.

**Epic 23 stories** are riddled with references to the old model:
- Story 23.3 says `targetNote.pitch(in: tuningSystem).frequency(referencePitch:)` ‚Äî that API won't exist
- Stories 23.1-23.2 reference `Pitch` and `pitch(at:in:)` implicitly
- Default parameters `tuningSystem: TuningSystem = .equalTemperament` appear in 23.2 and 23.3 ‚Äî exactly what we said we don't want

These don't need rewriting *today*, but they do need revision before implementation. The question is: do we revise them now as part of this planning session, or flag them for revision when we start Epic 23?

---

üèÉ **Bob**: *clicks pen crisply*

Let me be the process voice here. We need to be precise about what changes and in what order. Here's my assessment:

**Work that needs to happen, in dependency order:**

1. **NEW Story ‚Äî "Introduce DetunedMIDINote and Two-World Architecture"**
   - Introduce `DetunedMIDINote(note:offset:)`
   - Add `TuningSystem.frequency(for:referencePitch:)` bridge methods
   - Migrate all `Pitch` usage to new model (5 production call sites)
   - Internalize SoundFont's Frequency‚ÜíMIDI decomposition
   - Remove `Pitch` struct
   - Remove `MIDINote.pitch(at:in:)`
   - Update `project-context.md`
   - This **must** come before the rename story, because it changes the shape of `Comparison`

2. **Story 22.2 (Unified Reference/Target Naming) ‚Äî revised**
   - Same rename: `note1`‚Üí`referenceNote`, `note2`‚Üí`targetNote`
   - But now `Comparison` gets `targetNote: DetunedMIDINote` instead of separate fields
   - Slightly different scope, same intent

3. **Story 22.3 ‚Äî DROP**
   - NotePlayer keeps `Frequency`. Premise invalidated.

4. **Story 22.4 (Extract SoundSourceProvider) ‚Äî unchanged**
   - Independent. Can be done in parallel with anything.

5. **Epic 23 stories ‚Äî flag for revision**
   - All four stories need updated API references
   - But rewriting them now, before Epic 22 is done, risks churn
   - Better: revise Epic 23 stories when we begin Epic 23 planning

**Also affected:**
- **Story 21.3** was "Implement Pitch Value Type" ‚Äî already done. The new story effectively *undoes* parts of 21.3. That's fine ‚Äî architectural understanding evolves. The retrospective should note this.
- **Epic 21** should stay marked as done. Story 21.3 delivered value (it taught us what Pitch should and shouldn't be).

---

üíª **Amelia**: `sprint-status.yaml` ‚Äî there's also a discrepancy to clean up. The done story `22-2-domain-type-documentation-and-api-cleanup` was completed per git history but the sprint-status shows `22-2-unified-reference-target-naming: backlog`. Looks like the numbering shifted after the old 22.2 was done. The new DetunedMIDINote story needs a clear number that doesn't collide.

I'd suggest:
- Keep `22-1` as done (FrequencyCalculation migration)
- The completed "Domain Type Documentation and API Cleanup" is effectively a bonus cleanup ‚Äî it's done, track it or not
- New: `22-2` becomes "Introduce DetunedMIDINote and Two-World Architecture"
- Revised: `22-3` becomes "Unified Reference/Target Naming" (with DetunedMIDINote)
- Dropped: old 22.3 (NotePlayer Takes Pitch)
- `22-4` stays as "Extract SoundSourceProvider Protocol"

---

üî¨ **Dr. Quinn**: One more thing the team should consider. The `adjustPitch` and `commitPitch` methods in `PitchMatchingSession` currently do inline frequency math:

```swift
let frequency = referenceFrequency * pow(2.0, centOffset / 1200.0)
```

This is physical-world arithmetic ‚Äî adjusting an already-computed Hz value by a cent delta. It's *not* a logical‚Üíphysical bridge crossing. It should stay as-is. But it would benefit from a named helper to make the intent clear ‚Äî something like `Frequency.adjusted(byCents:)`. That could be a sub-task of the new story, or left for later.

---

üìã **John**: So to summarize the proposed revised roadmap for Epic 22:

| # | Story | Status |
|---|-------|--------|
| 22.1 | Migrate FrequencyCalculation to Domain Types | **done** |
| 22.2 | Introduce DetunedMIDINote and Two-World Architecture | **new** |
| 22.3 | Unified Reference/Target Naming (with DetunedMIDINote) | **revised** |
| 22.4 | Extract SoundSourceProvider Protocol | **unchanged** |

Old 22.3 (NotePlayer Takes Pitch) ‚Üí **dropped**.

Epic 23 stories ‚Üí **flagged for revision** when we begin that epic.

**Bob asks: Michael, does this ordering and scoping look right to you? And do you want us to revise the Epic 23 stories now while we have the full context fresh, or defer that?**

`[E] Exit Party Mode - End the collaborative session`

### üßë Human (21:38:54)

Please revise Epic 23 now.

### ü§ñ Assistant (21:40:10)

Let me quickly check one more thing about how `PitchMatchingChallenge` is currently structured.

### ü§ñ Assistant (21:41:25)

Good, now I have the full picture. Let me let the agents work through the revision.

---

üèÉ **Bob**: Right, let's be systematic. I'll walk through each Epic 23 story, identify every line that conflicts with the two-world architecture, and propose the revision. Winston and Amelia will sanity-check.

---

### **Story 23.1: Data Model and Value Type Updates for Interval Context**

üèÉ **Bob**: The *intent* is still valid ‚Äî records need to carry interval context. But the *details* need updating.

**What changes:**

After Epic 22 is done, `Comparison` will already have `referenceNote: MIDINote` and `targetNote: DetunedMIDINote`. For unison training, `targetNote` is `DetunedMIDINote(referenceNote)` with a non-zero offset (the training challenge). For interval training, `targetNote.note` is the transposed note.

So the interval is *implicit* in the distance between `referenceNote` and `targetNote.note` ‚Äî recoverable via `Interval.between(referenceNote, targetNote.note)`. We don't need to store it separately on `Comparison`.

But we *do* need it on the **records** for queryability.

üíª **Amelia**: Agreed. `ComparisonRecord` and `PitchMatchingRecord` are SwiftData models ‚Äî you can't efficiently query "all perfect-fifth results" without a stored field. The value types can derive it; the records should store it.

üèóÔ∏è **Winston**: And `PitchMatchingChallenge` needs a `targetNote: MIDINote` ‚Äî the note the user tunes toward. For unison, `targetNote == referenceNote`. For intervals, `targetNote = referenceNote.transposed(by: interval)`. The `initialCentOffset` then detuning from *that* target.

üèÉ **Bob**: Here's the revised story:

> **Story 23.1: Data Model and Value Type Updates for Interval Context**
>
> **Acceptance Criteria:**
>
> **Given** `ComparisonRecord` has `referenceNote`, `targetNote`, `centOffset`, `isCorrect`, `timestamp`
> **When** `interval: Interval` and `tuningSystem: TuningSystem` fields are added
> **Then** the SwiftData schema accepts the new fields
> **And** `TrainingDataStore` saves and loads both
> **And** `interval` is stored explicitly for efficient querying (even though it's derivable from `referenceNote` and `targetNote`)
>
> **Given** `PitchMatchingRecord` has `referenceNote`, `initialCentOffset`, `userCentError`, `timestamp`
> **When** `targetNote: MIDINote`, `interval: Interval`, and `tuningSystem: TuningSystem` fields are added
> **Then** `TrainingDataStore` saves and loads all new fields
> **And** `targetNote` represents the note the user was trying to match (equals `referenceNote` for unison)
>
> **Given** `PitchMatchingChallenge` value type
> **When** `targetNote: MIDINote` field is added
> **Then** it represents the correct interval note the user should tune toward
> **And** for unison: `targetNote == referenceNote`
> **And** for intervals: `targetNote == referenceNote.transposed(by: interval)`
>
> **Given** `CompletedComparison` value type
> **When** `tuningSystem: TuningSystem` field is added
> **Then** `ComparisonSession` populates it from its session-level parameter
>
> **Given** `CompletedPitchMatching` value type
> **When** `targetNote: MIDINote` and `tuningSystem: TuningSystem` fields are added
> **Then** `PitchMatchingSession` populates them from session-level parameters
>
> **Given** `Comparison` already has `targetNote: DetunedMIDINote` (from Story 22.3)
> **When** no structural changes are needed to `Comparison`
> **Then** its shape is confirmed correct for interval training
>
> **Given** no production user base exists
> **When** SwiftData schema changes are applied
> **Then** no `SchemaMigrationPlan` is needed

**Removed:** All references to `Pitch`. No mention of `centDifference` renaming (done in 22.3).

---

### **Story 23.2: ComparisonSession and Strategy Interval Parameterization**

üèóÔ∏è **Winston**: This is where the biggest API changes land. The old story had `tuningSystem: TuningSystem = .equalTemperament` as a default. We kill that. And the frequency computation path changes entirely.

üèÉ **Bob**: Revised:

> **Story 23.2: ComparisonSession and Strategy Interval Parameterization**
>
> **Acceptance Criteria:**
>
> **Given** `ComparisonSession` has a `startTraining()` method
> **When** it gains parameters `intervals: Set<Interval>` and `tuningSystem: TuningSystem` (no default)
> **Then** the interval set must be non-empty (enforced by precondition)
> **And** both parameters are stored for the training run
>
> **Given** a training session with `intervals: [.prime]`
> **When** comparisons are generated
> **Then** behavior is identical to pre-interval implementation ‚Äî `targetNote.note == referenceNote`
>
> **Given** a training session with `intervals: [.perfectFifth]`
> **When** a comparison is generated
> **Then** the strategy picks a reference note, then `targetNote.note = referenceNote.transposed(by: .perfectFifth)`
> **And** `targetNote` is a `DetunedMIDINote` with the training cent offset applied
> **And** reference note selection constrains the upper bound by `interval.semitones` to keep `targetNote.note` within MIDI range (0‚Äì127)
>
> **Given** `NextComparisonStrategy` protocol
> **When** it gains `interval: Interval` and `tuningSystem: TuningSystem` parameters (no defaults)
> **Then** `KazezNoteStrategy` computes `targetNote.note` from the interval via `transposed(by:)`
>
> **Given** the frequency computation for playback
> **When** the session needs to play the reference and target notes
> **Then** reference frequency uses `tuningSystem.frequency(for: referenceNote, referencePitch:)`
> **And** target frequency uses `tuningSystem.frequency(for: targetNote, referencePitch:)` where `targetNote` is the `DetunedMIDINote`
>
> **Given** `ComparisonSession` has `currentInterval` and `isIntervalMode` properties
> **When** `currentInterval` is `.prime` **Then** `isIntervalMode` returns `false`
> **When** `currentInterval` is `.perfectFifth` **Then** `isIntervalMode` returns `true`
>
> **Given** `CompletedComparison` now carries `tuningSystem`
> **When** `ComparisonObserver` receives it
> **Then** `tuningSystem` is persisted to `ComparisonRecord`

üíª **Amelia**: Note the key difference from the old story ‚Äî no `pitch(at:in:)`, no `Pitch` anywhere. The strategy uses `transposed(by:)` for the logical move, wraps the result in a `DetunedMIDINote` with the training offset, and the bridge handles the rest.

---

### **Story 23.3: PitchMatchingSession Interval Parameterization**

üî¨ **Dr. Quinn**: This one has the most subtle change. The old story said the tunable frequency target uses `targetNote.pitch(in: tuningSystem).frequency(referencePitch:)`. That entire chain is gone. Let me trace the new flow:

1. Session picks `referenceNote` and `interval`
2. `targetNote = referenceNote.transposed(by: interval)` ‚Äî a plain `MIDINote`
3. "Correct" target frequency: `tuningSystem.frequency(for: targetNote, referencePitch:)`
4. Detuned starting point: `tuningSystem.frequency(for: DetunedMIDINote(note: targetNote, offset: Cents(initialCentOffset)), referencePitch:)`
5. Slider adjustment: physical-world arithmetic from the detuned frequency ‚Äî stays as inline math

üèÉ **Bob**: Revised:

> **Story 23.3: PitchMatchingSession Interval Parameterization**
>
> **Acceptance Criteria:**
>
> **Given** `PitchMatchingSession` has a `startPitchMatching()` method
> **When** it gains parameters `intervals: Set<Interval>` and `tuningSystem: TuningSystem` (no default)
> **Then** the interval set must be non-empty (enforced by precondition)
> **And** both parameters are stored for the training run
>
> **Given** a pitch matching session with `intervals: [.prime]`
> **When** a challenge is generated
> **Then** `targetNote == referenceNote` ‚Äî identical to pre-interval behavior
>
> **Given** a pitch matching session with `intervals: [.perfectFifth]`
> **When** a challenge is generated
> **Then** `targetNote = referenceNote.transposed(by: .perfectFifth)`
> **And** `initialCentOffset` is applied relative to the target note
> **And** reference note selection constrains the upper bound by `interval.semitones`
>
> **Given** the reference note frequency for playback
> **When** the session computes it
> **Then** it uses `tuningSystem.frequency(for: referenceNote, referencePitch:)`
>
> **Given** the detuned starting frequency for the tunable note
> **When** the session computes it
> **Then** it uses `tuningSystem.frequency(for: DetunedMIDINote(note: targetNote, offset: Cents(initialCentOffset)), referencePitch:)`
>
> **Given** the slider adjusts the tunable note in real time
> **When** `adjustPitch` and `commitPitch` are called
> **Then** they apply cent-based frequency arithmetic relative to the already-computed reference frequency
> **And** this remains physical-world arithmetic (no bridge crossing)
>
> **Given** `userCentError` represents deviation from the correct interval pitch
> **When** the session computes it
> **Then** it measures cents between user's final frequency and the correct target frequency
>
> **Given** `CompletedPitchMatching` carries `targetNote` and `tuningSystem`
> **When** `PitchMatchingObserver` receives it
> **Then** both fields are persisted to `PitchMatchingRecord`
>
> **Given** `PitchMatchingSession` has `currentInterval` and `isIntervalMode` properties
> **When** `currentInterval` is `.perfectFifth` **Then** `isIntervalMode` returns `true`

**Removed:** `targetNote.pitch(in: tuningSystem).frequency(referencePitch:)` ‚Äî the old bridge-crossing path.

---

### **Story 23.4: Training Screen Interval Label and Observer Verification**

üèÉ **Bob**: This one is mostly UI and data flow verification. Minimal changes needed ‚Äî just removing stale references.

> **Story 23.4: Training Screen Interval Label and Observer Verification**
>
> *Acceptance criteria unchanged* except:
> - Remove: "no changes to `PitchDiscriminationProfile` or `PitchMatchingProfile` protocols"
>   - (This may or may not hold ‚Äî verify during implementation, don't constrain it now)
> - Confirm: observer value types carry `tuningSystem` and `targetNote` as specified in 23.1
> - All frequency computations in screens flow through `TuningSystem.frequency(for:referencePitch:)` ‚Äî no direct `Pitch` construction

---

üèóÔ∏è **Winston**: One pattern I want to call out across all four stories. The old Epic 23 had a hidden assumption: that `TuningSystem` only affects note construction (via `pitch(at:in:)`), and frequency is "just math." In the new model, the two-world boundary is **explicit at every call site**. Every time a story says "compute frequency," the acceptance criteria now name the bridge method. That's the real win ‚Äî no implicit assumptions survive into Epic 23.

üìã **John**: Let me put the full revised roadmap together:

**Epic 22 (revised):**
| # | Story | Status |
|---|-------|--------|
| 22.1 | Migrate FrequencyCalculation to Domain Types | done |
| 22.2 | Introduce DetunedMIDINote and Two-World Architecture | **new** |
| 22.3 | Unified Reference/Target Naming (with DetunedMIDINote) | **revised** |
| ~~22.3~~ | ~~NotePlayer Protocol Takes Pitch~~ | **dropped** |
| 22.4 | Extract SoundSourceProvider Protocol | unchanged |

**Epic 23 (revised):**
| # | Story | Key changes |
|---|-------|-------------|
| 23.1 | Data Model + Value Type Updates | No `Pitch` refs; `Comparison.targetNote` already `DetunedMIDINote`; explicit `interval` on records |
| 23.2 | ComparisonSession Interval Parameterization | No tuningSystem default; frequency via bridge; `transposed(by:)` for intervals |
| 23.3 | PitchMatchingSession Interval Parameterization | No tuningSystem default; bridge for all freq computation; slider stays physical-world math |
| 23.4 | Training Screen Labels + Observer Verification | Terminology cleanup only |

**Epic 24:** Unaffected ‚Äî it routes `intervals` and `tuningSystem` parameters through navigation, which is orthogonal to the internal architecture.

---

**Michael, that's the complete revision of Epic 23 aligned to the two-world architecture. Anything you'd like to adjust, or shall we wrap?**

`[E] Exit Party Mode - End the collaborative session`

### üßë Human (21:43:08)

Please save the revised stories and roadmap to the appropriate docs files.

### ü§ñ Assistant (21:43:16)

Time to save this. Let me read the exact sections I need to edit.

### ü§ñ Assistant (21:43:21)

Now let me make the edits. I'll update Epic 22 (description, stories 22.2-22.3) and Epic 23 (all four stories).

### ü§ñ Assistant (21:44:12)

Now update Epic 23:

### ü§ñ Assistant (21:45:21)

Now update the sprint-status.yaml:

### ü§ñ Assistant (21:45:32)

Now let me verify the edits look correct:

### ü§ñ Assistant (21:45:36)

Let me also quickly verify the Epic 23 section in epics.md reads correctly:

### ü§ñ Assistant (21:45:41)

Good ‚Äî all stories are in place and correctly numbered. Let me verify there are no stale `Pitch` references left in the revised Epic 23 section:

### ü§ñ Assistant (21:45:51)

Good ‚Äî no stale `Pitch` references in the revised Epic 23 section (lines 2352+). There are older references in the pre-existing Arch-A/Arch-B notes and completed epics (13, 16, etc.), which is expected ‚Äî those describe history.

Let me check for any remaining `pitch(at:in:)` references in the revised sections:

### ü§ñ Assistant (21:46:02)

References at lines 167 (Arch-A, historical), 2192/2206 (Story 21.3, already done), and 2275/2277 (new Story 22.2, which *removes* `pitch(at:in:)`). All correct ‚Äî no stale references in the revised sections.

---

Done. Here's what was saved:

**`docs/planning-artifacts/epics.md`:**
- **Epic 22 description** updated to reference two-world architecture
- **Story 22.2** replaced: "Unified Reference/Target Naming" ‚Üí "Introduce DetunedMIDINote and Two-World Architecture"
- **Story 22.3** replaced: "NotePlayer Protocol Takes Pitch" (dropped) ‚Üí "Unified Reference/Target Naming" (revised, with DetunedMIDINote)
- **Story 22.4** unchanged
- **Stories 23.1‚Äì23.4** all revised: no `Pitch` references, no tuning system defaults, all frequency computations through `TuningSystem.frequency(for:referencePitch:)`, intervals via `transposed(by:)`, slider stays physical-world arithmetic

**`docs/implementation-artifacts/sprint-status.yaml`:**
- Story IDs renumbered to match new 22.2/22.3
- Comment block explaining the renumbering and the dropped story

`[E] Exit Party Mode - End the collaborative session`

### üßë Human (21:48:02)

Very well. Thanks, guys.

### ü§ñ Assistant (21:48:13)

üéâ **PARTY MODE DEACTIVATING** üéâ

---

üèóÔ∏è **Winston**: Solid session. The two-world model is the right call ‚Äî it'll age well.

üíª **Amelia**: Five call sites. Clean kill. Looking forward to implementing 22.2.

üî¨ **Dr. Quinn**: The can of worms is now a neatly labeled jar. *tips hat*

üìã **John**: Roadmap's tight. Go build.

üèÉ **Bob**: Stories are scoped, ordered, and tracked. No ambiguity left.

---

Good session, Michael. The key outcomes:

1. **New architectural principle**: logical world (MIDINote, DetunedMIDINote, Interval, Cents) vs. physical world (Frequency), bridged by `TuningSystem.frequency(for:referencePitch:)` ‚Äî no defaults
2. **Epic 22 revised**: new story 22.2 (DetunedMIDINote), old NotePlayer-takes-Pitch story dropped, naming story shifted to 22.3
3. **Epic 23 revised**: all four stories aligned to two-world model, no stale `Pitch` references
4. **Files saved**: `epics.md` and `sprint-status.yaml` updated

### üßë Human (21:48:28)

Oh, you still need to commit your changes.

### ü§ñ Assistant (21:48:57)

Committed as `a20bd35`. Two files changed, clean working tree.

### üßë Human (21:49:21)

<command-name>/exit</command-name>
            <command-message>exit</command-message>
            <command-args></command-args>

### üßë Human (21:49:21)

<local-command-stdout>Bye!</local-command-stdout>

---

[‚Üê Previous (c82bbc7c29)](c82bbc7c29.md) | [Index](index.md) | [Next (d6f3a93a2e) ‚Üí](d6f3a93a2e.md)
