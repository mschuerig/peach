---
commit: "f6198d2e6347fae8ec9f81b7452e5cdabdc12347"
date: "2026-02-28T16:27:38+01:00"
author: "Michael Sch√ºrig <michael@schuerig.de>"
subject: "Add v0.3 interval training epics and stories (Epics 21-24)"
sessions: ["e208109c-dd3e-4a04-81b1-3ba9d5fa357d"]
prev: "531fe1335b.md"
next: "5f1eb1ec60.md"
---

[‚Üê Previous (531fe1335b)](531fe1335b.md) | [Index](index.md) | [Next (5f1eb1ec60) ‚Üí](5f1eb1ec60.md)

# Commit f6198d2e63

**Date:** 2026-02-28 16:27:38 UTC+01:00  
**Author:** Michael Sch√ºrig <michael@schuerig.de>

## Commit message

Add v0.3 interval training epics and stories (Epics 21-24)

Four epics with 13 stories covering FR53-FR67 and NFR14:
- Epic 21: Interval domain foundation (Interval, TuningSystem, Pitch types)
- Epic 22: Prerequisite refactorings (renames, NotePlayer‚ÜíPitch, FrequencyCalculation migration, SoundSourceProvider)
- Epic 23: Generalize training for intervals (data models, session parameterization, strategy, interval label)
- Epic 24: Start Screen integration (NavigationDestination, four training buttons)

Co-Authored-By: Claude Opus 4.6 <noreply@anthropic.com>

## Changed files

```
docs/planning-artifacts/epics.md | 486 ++++++++++++++++++++++++++++++++++++++-
 1 file changed, 485 insertions(+), 1 deletion(-)
```

## Session `e208109c‚Ä¶`

*2026-02-28 15:05:54 UTC ‚Üí 2026-02-28 15:27:44 UTC*

### üßë Human (15:05:54)

<command-message>bmad-bmm-create-epics-and-stories</command-message>
<command-name>/bmad-bmm-create-epics-and-stories</command-name>
<command-args>for v0.3</command-args>

### ü§ñ Assistant (15:06:05)

Now let me search for the required documents and load the template.

### ü§ñ Assistant (15:06:15)

I found all three required documents. Let me now read them to extract the requirements. Since the user specified "for v0.3", I'll focus on v0.3 scope.

### ü§ñ Assistant (15:06:21)

Let me read the v0.3-specific sections from the architecture and UX design documents.

### ü§ñ Assistant (15:06:31)

Let me read the v0.3 amendment sections from both documents.

### ü§ñ Assistant (15:06:47)

Welcome to comprehensive epic and story creation, Michael!

I've validated the prerequisite documents and found all three required documents:

1. **PRD.md** - Found at `docs/planning-artifacts/prd.md` (complete, includes v0.3 additions FR53‚ÄìFR67, Journeys 7‚Äì8)
2. **Architecture.md** - Found at `docs/planning-artifacts/architecture.md` (complete, includes v0.3 amendment for interval training)
3. **UX Design Specification.md** - Found at `docs/planning-artifacts/ux-design-specification.md` (complete, includes v0.3 interval training amendment)

I also found a **UX Design Validation Report** (`ux-design-validation-report-2026-02-28.md`) which may contain additional context.

Since you specified **v0.3 scope**, I'll focus the requirements extraction on the interval training additions (FR53‚ÄìFR67, Journeys 7‚Äì8), plus any prerequisite refactorings specified in the architecture.

Are there any other documents I should include, or should I exclude any of these? And should I scope the epics strictly to v0.3 new work, or also include prerequisite refactorings that the architecture specifies?

### üßë Human (15:07:54)

scope to v0.3 only, include prerequisite refactorings, no extra docs needed

### ü§ñ Assistant (15:08:00)

Got it ‚Äî v0.3 scope only, prerequisite refactorings included, no extra docs. Let me extract and organize all the requirements now.

### ü§ñ Assistant (15:09:25)

There's already an existing `epics.md` with MVP and v0.2 content. Let me understand its full structure before appending v0.3.

### ü§ñ Assistant (15:09:32)

Now let me also check the existing requirements inventory section and the epic list section.

### ü§ñ Assistant (15:09:51)

Good. I now have the full picture. The existing `epics.md` covers MVP (Epics 1‚Äì7, 10) and v0.2 (Epics 11‚Äì20). I need to append v0.3 content. Here's what I've extracted:

**Functional Requirements (15 FRs):** FR53‚ÄìFR67, covering interval domain types, interval comparison, interval pitch matching, Start Screen integration, and the fixed-interval scope constraint.

**Non-Functional Requirements (4 relevant):**
- NFR-Tuning Precision (new, specific to interval computations)
- NFR3 (frequency precision, preserved through domain migration)
- NFR10/NFR11 (data integrity, applies to new record fields)
- NFR6/NFR8 (accessibility, applies to new UI elements)

**Additional Requirements from Architecture:**
- 5 prerequisite refactorings (Arch-A through Arch-E)
- Session parameterization, strategy updates, data model updates, navigation updates, profile pass-through

**Additional Requirements from UX:**
- Target interval label, Start Screen 4-button layout, screen reuse, feedback/interruption patterns unchanged

Here's a summary of what was extracted:

- **15 Functional Requirements** (FR53‚ÄìFR67)
- **4 relevant NFRs** (tuning precision, frequency precision, data integrity, accessibility)
- **5 architecture prerequisite refactorings** (domain types, NotePlayer protocol, FrequencyCalculation migration, reference/target naming, SoundSourceProvider)
- **Architecture session/data updates** (parameterization, strategy, data models, navigation, profiles)
- **UX requirements** (interval label, 4-button Start Screen, screen reuse)

Do these extracted requirements accurately represent what needs to be built for v0.3? Any additions or corrections?

**Confirm the Requirements are complete and correct to [C] continue:**

### üßë Human (15:10:37)

c

### ü§ñ Assistant (15:10:43)

Let me save the v0.3 requirements to the document and load the next step.

### ü§ñ Assistant (15:11:06)

Now let me append the v0.3 requirements to the FR list, NFR list, additional requirements, and FR coverage map sections. First, let me add FRs after FR52.

### ü§ñ Assistant (15:11:26)

Now add the v0.3 additional requirements after the v0.2 UX section.

### ü§ñ Assistant (15:11:52)

Now add FR53‚ÄìFR67 to the coverage map. Let me find the end of the current map.

### ü§ñ Assistant (15:12:02)

Now let me load and follow step 2.

### ü§ñ Assistant (15:13:26)

I've reviewed all the extracted requirements. Here's my proposed epic structure for v0.3:

---

**4 epics, 15 FRs covered, linear dependency chain:**

### Epic 21: Speak the Language ‚Äî Interval Domain Foundation
The system can represent musical intervals and compute precise interval frequencies using tuning systems ‚Äî the domain foundation for all interval training features.
**FRs covered:** FR53, FR54, FR55
**NFRs covered:** NFR14 (tuning precision)
**Scope:** `Interval` enum, `TuningSystem` enum, `Pitch` struct, `MIDINote` extensions (`transposed(by:)`, `pitch(at:in:)`), `Frequency.concert440`. All pure value types, no dependencies on existing code. Full test coverage.

### Epic 22: Clean Slate ‚Äî Prerequisite Refactorings
Codebase uses unified reference/target naming, domain-native Pitch type throughout NotePlayer, and decoupled sound source dependency ‚Äî so that interval generalization proceeds cleanly without conflating new features with refactoring.
**FRs covered:** None (refactoring only, enables FR56‚ÄìFR67)
**Scope:** Arch-B (NotePlayer takes Pitch), Arch-C (FrequencyCalculation migration + deletion), Arch-D (note1‚ÜíreferenceNote, note2‚ÜítargetNote, centDifference‚ÜícentOffset renames), Arch-E (SoundSourceProvider protocol). All tests continue to pass.
**Depends on:** Epic 21 (Pitch type required for Arch-B and Arch-C)

### Epic 23: Intervals Everywhere ‚Äî Generalize Training for Intervals
Both comparison and pitch matching sessions accept interval parameters, data models record full interval context, the adaptive algorithm computes interval-aware targets, and training screens show the target interval ‚Äî generalizing the training experience from unison-only to any musical interval.
**FRs covered:** FR57, FR58, FR59, FR61, FR62, FR63, FR64, FR66
**Scope:** Data model updates (ComparisonRecord, PitchMatchingRecord gain tuningSystem/targetNote), value type updates, session parameterization (`startTraining(intervals:tuningSystem:)`), NextComparisonStrategy update, MIDI range boundary enforcement, conditional target interval label on both training screens, observer/profile pass-through verification.
**Depends on:** Epic 22 (renamed fields, Pitch-based NotePlayer)

### Epic 24: Four Modes, One App ‚Äî Start Screen Integration
Users see four training modes on the Start Screen and can launch interval comparison or interval pitch matching with a single tap, starting with the perfect fifth interval.
**FRs covered:** FR56, FR60, FR65, FR67
**Scope:** NavigationDestination parameterized with `intervals: Set<Interval>`, Start Screen four buttons with visual separator (unison `.borderedProminent` + interval `.bordered`), `.comparison(intervals: [.perfectFifth])` and `.pitchMatching(intervals: [.perfectFifth])` routing. Fixed to perfect fifth for v0.3.
**Depends on:** Epic 23 (parameterized sessions)

---

**FR Coverage:**
| FR | Epic | Description |
|---|---|---|
| FR53 | 21 | Interval value object |
| FR54 | 21 | Frequency via TuningSystem |
| FR55 | 21 | Extensible tuning systems |
| FR56 | 24 | Interval comparison Start Screen button |
| FR57 | 23 | Reference + second note at interval ¬± deviation |
| FR58 | 23 | Higher/lower relative to correct interval |
| FR59 | 23 | Feedback/haptic/interruption identical |
| FR60 | 24 | Interval pitch matching Start Screen button |
| FR61 | 23 | Interval PM target is interval pitch |
| FR62 | 23 | Slider to match target interval |
| FR63 | 23 | PM feedback/interruption identical |
| FR64 | 23 | Interval PM result recording |
| FR65 | 24 | Four training buttons |
| FR66 | 23 | Unison = prime case |
| FR67 | 24 | Fixed perfect fifth |

Does this epic structure align with your vision? Should we adjust any groupings or boundaries?

**Select an Option:** [A] Advanced Elicitation [P] Party Mode [C] Continue

### üßë Human (15:14:54)

c

### ü§ñ Assistant (15:15:07)

Let me update the coverage map to match the approved numbering and add the v0.3 epics to the document.

### ü§ñ Assistant (15:15:14)

Now add the v0.3 epics to the Epic List section.

### ü§ñ Assistant (15:15:24)

Now update the frontmatter.

### ü§ñ Assistant (15:15:31)

Now loading step 3.

### ü§ñ Assistant (15:17:02)

Epics saved. Now let's create stories for each epic, starting with **Epic 21**.

---

## Epic 21: Speak the Language ‚Äî Interval Domain Foundation

**Goal:** The system can represent musical intervals and compute precise interval frequencies using tuning systems.
**FRs covered:** FR53, FR54, FR55 | **NFRs:** NFR14
**Architecture reference:** Arch-A (new domain types)

I propose **3 stories**, following the architecture's implementation sequence ‚Äî each produces new files with full test coverage, no existing code dependencies:

---

### Story 21.1: Implement Interval Enum and MIDINote Transposition

As a **developer building interval training**,
I want an `Interval` enum representing musical intervals from Prime through Octave, with a `MIDINote.transposed(by:)` extension and an `Interval.between(_:_:)` factory,
So that intervals are first-class domain concepts with compile-time safety and the system can compute transposed notes.

**Acceptance Criteria:**

**Given** the `Interval` enum exists with cases Prime through Octave
**When** accessing `Interval.perfectFifth.semitones`
**Then** it returns `7`
**And** all 13 cases (Prime through Octave) have correct semitone values (0‚Äì12)

**Given** a MIDINote within valid range
**When** calling `MIDINote(60).transposed(by: .perfectFifth)`
**Then** it returns `MIDINote(67)`

**Given** two MIDINote values 7 semitones apart
**When** calling `Interval.between(MIDINote(60), MIDINote(67))`
**Then** it returns `.perfectFifth`

**Given** two MIDINote values more than 12 semitones apart
**When** calling `Interval.between(_:_:)`
**Then** it throws an error (distance outside Prime‚ÄìOctave range)

**Given** `Interval` conforms to `Hashable`, `Sendable`, `CaseIterable`, `Codable`
**When** encoding and decoding an `Interval` value
**Then** round-trip produces the same value

---

### Story 21.2: Implement TuningSystem Enum

As a **developer building interval training**,
I want a `TuningSystem` enum that computes the cent offset for any interval,
So that interval frequencies are derived from a pluggable tuning system with 0.1-cent precision (NFR14).

**Acceptance Criteria:**

**Given** `TuningSystem.equalTemperament`
**When** calling `centOffset(for: .perfectFifth)`
**Then** it returns `700.0` (exactly 7 √ó 100)

**Given** `TuningSystem.equalTemperament`
**When** calling `centOffset(for: .prime)`
**Then** it returns `0.0`

**Given** `TuningSystem.equalTemperament`
**When** calling `centOffset(for: .octave)`
**Then** it returns `1200.0`

**Given** `TuningSystem` conforms to `Hashable`, `Sendable`, `CaseIterable`, `Codable`
**When** encoding and decoding a `TuningSystem` value
**Then** round-trip produces the same value

**Given** the requirement that adding a new tuning system requires no changes to interval or training logic (FR55)
**When** a hypothetical new case is added to `TuningSystem`
**Then** only `centOffset(for:)` needs a new switch case ‚Äî no other files change

---

### Story 21.3: Implement Pitch Value Type and MIDINote Integration

As a **developer building interval training**,
I want a `Pitch` struct (MIDINote + Cents) that computes its frequency, with `MIDINote.pitch(at:in:)` composing Interval + TuningSystem into a Pitch, and `Frequency.concert440`,
So that interval frequency computation flows through domain types with 0.1-cent precision.

**Acceptance Criteria:**

**Given** `Pitch(note: MIDINote(69), cents: 0)`
**When** calling `frequency(referencePitch: .concert440)`
**Then** it returns 440.0 Hz (A4 in 12-TET)

**Given** `Pitch(note: MIDINote(60), cents: 0)` (middle C)
**When** calling `frequency(referencePitch: .concert440)`
**Then** the result is accurate to within 0.1 cent of the theoretical value

**Given** `MIDINote(60)` and interval `.perfectFifth` in `.equalTemperament`
**When** calling `MIDINote(60).pitch(at: .perfectFifth, in: .equalTemperament)`
**Then** it returns `Pitch(note: MIDINote(67), cents: 0)` (G4 in 12-TET, cents = 0)

**Given** `MIDINote(60)` with default parameters
**When** calling `MIDINote(60).pitch()` (defaults: `.prime`, `.equalTemperament`)
**Then** it returns `Pitch(note: MIDINote(60), cents: 0)` (unison case)

**Given** `Frequency.concert440`
**When** accessed as a static constant
**Then** its value is `Frequency(440.0)`

**Given** `Pitch` conforms to `Hashable` and `Sendable`
**When** used as a dictionary key or passed across concurrency boundaries
**Then** it works correctly

---

**Epic 21 summary:** 3 stories, 3 new files (`Interval.swift`, `TuningSystem.swift`, `Pitch.swift`) + extensions on `MIDINote` and `Frequency`. All FR53, FR54, FR55 and NFR14 covered.

Does this breakdown look right? Any adjustments before I save and move to Epic 22?

### üßë Human (15:18:45)

looks good

### ü§ñ Assistant (15:19:34)

Epic 21 saved. Now **Epic 22: Clean Slate ‚Äî Prerequisite Refactorings**.

**Goal:** Codebase uses unified reference/target naming, domain-native Pitch type throughout NotePlayer, and decoupled sound source dependency.
**FRs covered:** None (refactoring only, enables FR56‚ÄìFR67)
**Architecture reference:** Arch-B, Arch-C, Arch-D, Arch-E

I propose **4 stories**, following the architecture's implementation sequence:

---

### Story 22.1: Migrate FrequencyCalculation to Domain Types

As a **developer building interval training**,
I want the standalone `FrequencyCalculation.swift` utility replaced by `Pitch.frequency(referencePitch:)` and `MIDINote.frequency(referencePitch:)` domain methods,
So that frequency computation lives on the domain types that own the data, and the redundant utility is deleted.

**Acceptance Criteria:**

**Given** `FrequencyCalculation.frequency(midiNote:cents:referencePitch:)` exists
**When** all call sites are migrated to `Pitch.frequency(referencePitch:)` or `MIDINote.frequency(referencePitch:)`
**Then** `FrequencyCalculation.swift` is deleted
**And** no file imports or references `FrequencyCalculation`
**And** NFR3 (0.1-cent frequency precision) is preserved ‚Äî existing frequency precision tests pass against the new domain methods
**And** the full test suite passes

---

### Story 22.2: Unified Reference/Target Naming

As a **developer building interval training**,
I want `note1`/`note2` renamed to `referenceNote`/`targetNote` and `note2CentOffset`/`centDifference` renamed to `centOffset` across all value types, records, sessions, strategies, observers, data store, tests, and docs,
So that naming is consistent with the reference/target mental model shared by all training modes.

**Acceptance Criteria:**

**Given** `ComparisonRecord` has fields `note1`, `note2`, `note2CentOffset`
**When** they are renamed to `referenceNote`, `targetNote`, `centOffset`
**Then** all references across code, tests, and docs use the new names
**And** no occurrence of `note1`, `note2`, `note2CentOffset`, or `centDifference` remains in Swift source files (except comments explaining the rename if needed)

**Given** `Comparison` has fields `note1`, `note2`, `centDifference`
**When** they are renamed to `referenceNote`, `targetNote`, `centOffset`
**Then** `ComparisonSession`, `NextComparisonStrategy`, `KazezNoteStrategy`, `ComparisonObserver` conformances, and all tests use the new names

**Given** `CompletedComparison` has fields `comparison.note1`, `comparison.note2`
**When** accessed through the renamed `Comparison` struct
**Then** all code paths use `comparison.referenceNote`, `comparison.targetNote`

**Given** `PitchMatchingRecord.referenceNote`, `PitchMatchingChallenge.referenceNote`, `CompletedPitchMatching.referenceNote` already use correct naming
**When** the rename is complete
**Then** these names remain unchanged

**Given** this is a pure rename with no functional changes
**When** the full test suite is run
**Then** all tests pass with no behavioral changes

---

### Story 22.3: NotePlayer Protocol Takes Pitch

As a **developer building interval training**,
I want the `NotePlayer` protocol to accept `Pitch` instead of `Frequency` in its `play()` methods,
So that the audio interface works with domain types and MIDI-based implementations receive their natural input.

**Acceptance Criteria:**

**Given** `NotePlayer.play(frequency:velocity:amplitudeDB:)` exists
**When** the signature is changed to `play(pitch:velocity:amplitudeDB:)`
**Then** all call sites pass `Pitch` instead of `Frequency`
**And** the default extension for fixed-duration playback uses `pitch:` instead of `frequency:`

**Given** `SoundFontNotePlayer` receives a `Pitch`
**When** playing a note
**Then** it maps `Pitch` (MIDINote + Cents) directly to MIDI noteOn + pitch bend
**And** no intermediate Hz‚ÜíMIDI conversion is needed

**Given** `PlaybackHandle.adjustFrequency` stays as `Frequency`
**When** sessions need to adjust a playing note's pitch
**Then** they compute `pitch.frequency(referencePitch:)` and pass the result to the handle

**Given** `MockNotePlayer` in tests
**When** updated to accept `Pitch`
**Then** all test assertions use `Pitch` values
**And** the full test suite passes

---

### Story 22.4: Extract SoundSourceProvider Protocol

As a **developer building interval training**,
I want a `SoundSourceProvider` protocol extracted from `SoundFontLibrary` so that `SettingsScreen` depends on the protocol via `@Environment`, not the concrete library,
So that the Settings feature is decoupled from the audio implementation.

**Acceptance Criteria:**

**Given** `SettingsScreen` directly depends on `SoundFontLibrary`
**When** `SoundSourceProvider` protocol is created with `availableSources` and `displayName(for:)`
**Then** `SoundFontLibrary` conforms to `SoundSourceProvider`
**And** `SettingsScreen` depends on `SoundSourceProvider` via `@Environment`

**Given** `SoundSourceProvider.swift` is created in `Core/Audio/`
**When** the protocol is used
**Then** `SettingsScreen` has no import of or reference to `SoundFontLibrary`

**Given** the sound source picker in Settings
**When** it renders available sources
**Then** behavior is identical to before the refactoring
**And** the full test suite passes

---

**Epic 22 summary:** 4 stories, all pure refactoring ‚Äî app behavior unchanged, all tests pass after each story. Arch-B, C, D, E covered.

Does this look right? Any adjustments before I save and move to Epic 23?

### üßë Human (15:21:19)

looks good

### ü§ñ Assistant (15:22:16)

Epic 22 saved. Now **Epic 23: Intervals Everywhere ‚Äî Generalize Training for Intervals**.

**Goal:** Both sessions accept interval parameters, data models record full interval context, strategy computes interval-aware targets, training screens show the target interval.
**FRs covered:** FR57, FR58, FR59, FR61, FR62, FR63, FR64, FR66
**Depends on:** Epic 22

I propose **4 stories**:

---

### Story 23.1: Data Model and Value Type Updates for Interval Context

As a **developer building interval training**,
I want `ComparisonRecord` and `PitchMatchingRecord` to carry `tuningSystem`, and `PitchMatchingRecord` to carry `targetNote`, and all value types (`Comparison`, `CompletedComparison`, `PitchMatchingChallenge`, `CompletedPitchMatching`) updated with target/tuning fields,
So that every training result records full interval context for data integrity and future analysis.

**Acceptance Criteria:**

**Given** `ComparisonRecord` has `referenceNote`, `targetNote`, `centOffset`, `isCorrect`, `timestamp`
**When** `tuningSystem` field is added with default `.equalTemperament`
**Then** the SwiftData schema accepts the new field
**And** `TrainingDataStore` saves and loads the `tuningSystem` field

**Given** `PitchMatchingRecord` has `referenceNote`, `initialCentOffset`, `userCentError`, `timestamp`
**When** `targetNote` and `tuningSystem` fields are added
**Then** `TrainingDataStore` saves and loads both new fields
**And** `targetNote` represents the note the user was trying to match (equals `referenceNote` for unison)

**Given** `Comparison` value type
**When** no changes are needed (fields already renamed in Epic 22)
**Then** `referenceNote`, `targetNote`, `centOffset` are confirmed correct

**Given** `CompletedComparison` value type
**When** `tuningSystem: TuningSystem` field is added
**Then** `ComparisonSession` populates it from its session-level parameter
**And** `TrainingDataStore` (as `ComparisonObserver`) persists it to `ComparisonRecord`

**Given** `PitchMatchingChallenge` value type
**When** `targetNote: MIDINote` field is added
**Then** it represents the note the user should tune toward (equals `referenceNote` for unison)

**Given** `CompletedPitchMatching` value type
**When** `targetNote: MIDINote` and `tuningSystem: TuningSystem` fields are added
**Then** `PitchMatchingSession` populates them from session-level parameters
**And** `TrainingDataStore` (as `PitchMatchingObserver`) persists them to `PitchMatchingRecord`

**Given** no production user base exists
**When** SwiftData schema changes are applied
**Then** no `SchemaMigrationPlan` is needed ‚Äî fresh schema version is acceptable

---

### Story 23.2: ComparisonSession and Strategy Interval Parameterization

As a **developer building interval training**,
I want `ComparisonSession.startTraining(intervals:tuningSystem:)` to accept an interval set, `NextComparisonStrategy` to compute interval-aware targets, and `currentInterval`/`isIntervalMode` observable state,
So that comparison training works with any musical interval while unison (`[.prime]`) behaves identically to current behavior (FR66).

**Acceptance Criteria:**

**Given** `ComparisonSession` has a `startTraining()` method
**When** it gains parameters `intervals: Set<Interval>` and `tuningSystem: TuningSystem = .equalTemperament`
**Then** the interval set must be non-empty (enforced by precondition)
**And** the session stores the set and tuning system for the training run

**Given** a training session with `intervals: [.prime]`
**When** comparisons are generated
**Then** behavior is identical to pre-interval implementation ‚Äî `targetNote` equals `referenceNote`

**Given** a training session with `intervals: [.perfectFifth]`
**When** a comparison is generated
**Then** `targetNote` = `referenceNote.transposed(by: .perfectFifth)`
**And** the cent offset is applied relative to the correct interval pitch

**Given** `NextComparisonStrategy` protocol
**When** it gains `interval: Interval` and `tuningSystem: TuningSystem` parameters
**Then** `KazezNoteStrategy` computes `targetNote` from the interval
**And** reference note selection constrains the upper bound by `interval.semitones` to keep target within valid MIDI range (0‚Äì127)

**Given** `ComparisonSession` has `currentInterval` and `isIntervalMode` properties
**When** `currentInterval` is `.prime`
**Then** `isIntervalMode` returns `false`
**When** `currentInterval` is `.perfectFifth`
**Then** `isIntervalMode` returns `true`

**Given** `CompletedComparison` now carries `tuningSystem`
**When** `ComparisonObserver` (TrainingDataStore) receives it
**Then** `tuningSystem` is persisted to `ComparisonRecord`

---

### Story 23.3: PitchMatchingSession Interval Parameterization

As a **developer building interval training**,
I want `PitchMatchingSession.startPitchMatching(intervals:tuningSystem:)` to accept an interval set and generate interval-aware challenges,
So that pitch matching training works with any musical interval while unison (`[.prime]`) behaves identically to current behavior (FR66).

**Acceptance Criteria:**

**Given** `PitchMatchingSession` has a `startPitchMatching()` method
**When** it gains parameters `intervals: Set<Interval>` and `tuningSystem: TuningSystem = .equalTemperament`
**Then** the interval set must be non-empty (enforced by precondition)
**And** the session stores the set and tuning system for the training run

**Given** a pitch matching session with `intervals: [.prime]`
**When** a challenge is generated
**Then** `targetNote` equals `referenceNote` ‚Äî identical to pre-interval behavior

**Given** a pitch matching session with `intervals: [.perfectFifth]`
**When** a challenge is generated
**Then** `targetNote` = `referenceNote.transposed(by: .perfectFifth)`
**And** `initialCentOffset` is relative to the correct interval pitch
**And** reference note selection constrains the upper bound by `interval.semitones`

**Given** `PitchMatchingSession` has `currentInterval` and `isIntervalMode` properties
**When** `currentInterval` is `.perfectFifth`
**Then** `isIntervalMode` returns `true`

**Given** `CompletedPitchMatching` now carries `targetNote` and `tuningSystem`
**When** `PitchMatchingObserver` (TrainingDataStore) receives it
**Then** both fields are persisted to `PitchMatchingRecord`
**And** `userCentError` represents deviation from the correct interval pitch (FR64)

**Given** the tunable note's frequency target
**When** the session computes it for slider interaction
**Then** it uses `targetNote.pitch(in: tuningSystem).frequency(referencePitch:)` ‚Äî the interval pitch, not the reference pitch

---

### Story 23.4: Training Screen Interval Label and Observer Verification

As a **developer building interval training**,
I want both `ComparisonScreen` and `PitchMatchingScreen` to show a conditional target interval label when in interval mode, and verify that observers/profiles handle the updated value types,
So that users see what interval they're training and all data flows correctly through the system.

**Acceptance Criteria:**

**Given** `ComparisonScreen` receives an `intervals` parameter
**When** `session.isIntervalMode` is `true`
**Then** a `Text` label showing the current interval name (e.g., "Perfect Fifth Up") is visible at the top of the screen, below navigation buttons and above the training interaction area
**And** the label uses `.headline` or `.title3` styling

**Given** `ComparisonScreen` is entered in unison mode (`intervals: [.prime]`)
**When** `session.isIntervalMode` is `false`
**Then** no interval label is visible ‚Äî the screen looks exactly as pre-v0.3

**Given** `PitchMatchingScreen` receives an `intervals` parameter
**When** `session.isIntervalMode` is `true`
**Then** a `Text` label showing the current interval name is visible at the top
**When** `session.isIntervalMode` is `false`
**Then** no interval label is visible

**Given** the target interval label
**When** VoiceOver is active
**Then** it reads "Target interval: Perfect Fifth Up" (or equivalent accessible label)

**Given** `ComparisonObserver` and `PitchMatchingObserver` receive updated value types with `tuningSystem` and `targetNote`
**When** interval training results flow through the observer path
**Then** profiles receive all data regardless of interval ‚Äî no filtering, no interval-aware aggregation
**And** no changes to `PitchDiscriminationProfile` or `PitchMatchingProfile` protocols

---

**Epic 23 summary:** 4 stories covering data models, both sessions, strategy, screens, and observers. FR57, FR58, FR59, FR61, FR62, FR63, FR64, FR66 all covered.

Does this look right? Any adjustments before I save and move to Epic 24?

### üßë Human (15:22:58)

looks good

### ü§ñ Assistant (15:23:38)

Epic 23 saved. Now the final one ‚Äî **Epic 24: Four Modes, One App ‚Äî Start Screen Integration**.

**Goal:** Users see four training modes on the Start Screen and can launch interval comparison or interval pitch matching with a single tap, starting with the perfect fifth interval.
**FRs covered:** FR56, FR60, FR65, FR67
**Depends on:** Epic 23

I propose **2 stories**:

---

### Story 24.1: NavigationDestination Parameterization and Routing

As a **musician using Peach**,
I want the navigation system to route interval training modes to the existing training screens with the correct interval parameters,
So that tapping an interval button launches the same screen with the interval context passed through.

**Acceptance Criteria:**

**Given** `NavigationDestination` has a `.training` case
**When** it is renamed to `.comparison(intervals: Set<Interval>)`
**Then** all existing navigation to comparison training uses `.comparison(intervals: [.prime])`

**Given** `NavigationDestination` has a `.pitchMatching` case
**When** it gains an `intervals` parameter as `.pitchMatching(intervals: Set<Interval>)`
**Then** all existing navigation to pitch matching uses `.pitchMatching(intervals: [.prime])`

**Given** the destination handler in `ContentView`
**When** routing `.comparison(let intervals)`
**Then** `ComparisonScreen(intervals: intervals)` is created
**And** the screen passes `intervals` to `session.startTraining(intervals:)`

**Given** the destination handler routing `.pitchMatching(let intervals)`
**When** navigating
**Then** `PitchMatchingScreen(intervals: intervals)` is created
**And** the screen passes `intervals` to `session.startPitchMatching(intervals:)`

**Given** `NavigationDestination` conforms to `Hashable`
**When** `Set<Interval>` is a parameter
**Then** the enum remains `Hashable` (since `Interval` is `Hashable`)

---

### Story 24.2: Start Screen Four Training Buttons

As a **musician using Peach**,
I want to see four training buttons on the Start Screen ‚Äî Comparison, Pitch Matching, Interval Comparison, and Interval Pitch Matching ‚Äî with a visual separator between unison and interval groups,
So that I can launch any training mode with a single tap (FR65).

**Acceptance Criteria:**

**Given** the Start Screen
**When** it loads
**Then** four training buttons are visible in a vertical stack:
1. "Comparison" ‚Äî `.borderedProminent` style (hero action, unchanged position)
2. "Pitch Matching" ‚Äî `.bordered` style
3. A subtle visual separator (spacing or divider)
4. "Interval Comparison" ‚Äî `.bordered` style
5. "Interval Pitch Matching" ‚Äî `.bordered` style

**Given** the "Interval Comparison" button
**When** tapped
**Then** it navigates to `.comparison(intervals: [.perfectFifth])` (FR56, FR67)

**Given** the "Interval Pitch Matching" button
**When** tapped
**Then** it navigates to `.pitchMatching(intervals: [.perfectFifth])` (FR60, FR67)

**Given** the "Comparison" button
**When** tapped
**Then** it navigates to `.comparison(intervals: [.prime])` ‚Äî unchanged behavior

**Given** the "Pitch Matching" button
**When** tapped
**Then** it navigates to `.pitchMatching(intervals: [.prime])` ‚Äî unchanged behavior

**Given** the Start Screen layout
**When** viewed in portrait and landscape on iPhone and iPad
**Then** all four buttons are accessible and the visual separator is visible
**And** the one-handed, thumb-friendly layout is preserved

---

**Epic 24 summary:** 2 stories ‚Äî navigation routing + Start Screen buttons. FR56, FR60, FR65, FR67 all covered.

All 4 epics complete (13 stories total). Does this look right before I save and move to final validation?

### üßë Human (15:24:58)

go ahead

### ü§ñ Assistant (15:25:11)

Now update frontmatter and load the final validation step.

### ü§ñ Assistant (15:25:53)

Running the final validation checks now.

---

## Final Validation ‚Äî v0.3 Epics and Stories

### 1. FR Coverage Validation

| FR | Story | Status |
|---|---|---|
| FR53 | 21.1 (Interval enum) | Covered |
| FR54 | 21.2 (TuningSystem centOffset) | Covered |
| FR55 | 21.2 (extensible via new enum case) | Covered |
| FR56 | 24.2 (Interval Comparison button) | Covered |
| FR57 | 23.2 (strategy computes interval target) | Covered |
| FR58 | 23.2 (session higher/lower relative to interval) | Covered |
| FR59 | 23.4 (verified identical feedback/haptic/interruption) | Covered |
| FR60 | 24.2 (Interval Pitch Matching button) | Covered |
| FR61 | 23.3 (PM target is interval pitch) | Covered |
| FR62 | 23.3 (slider targets interval pitch) | Covered |
| FR63 | 23.4 (verified identical PM feedback/interruption) | Covered |
| FR64 | 23.1 (data models) + 23.3 (session records) | Covered |
| FR65 | 24.2 (four buttons) | Covered |
| FR66 | 23.2 + 23.3 (prime = unison case) | Covered |
| FR67 | 24.2 (hardcoded .perfectFifth) | Covered |
| NFR14 | 21.2 (tuning precision) | Covered |

**Result: All 15 FRs + NFR14 covered. No gaps.**

### 2. Architecture Implementation Validation

- No starter template needed (existing project from MVP)
- No upfront database/entity creation ‚Äî data model changes in Story 23.1, which is the first story that needs them
- Architecture implementation sequence followed: domain types ‚Üí refactorings ‚Üí session/data ‚Üí UI

**Result: Pass.**

### 3. Story Quality Validation

- All 13 stories sized for single dev agent completion
- All stories have Given/When/Then acceptance criteria
- All stories reference specific FRs or architecture requirements
- No story requires future stories to function

**Result: Pass.**

### 4. Epic Structure Validation

- Epic 21: Delivers testable domain types (standalone value)
- Epic 22: Delivers clean codebase ready for generalization (standalone ‚Äî app still works identically)
- Epic 23: Delivers complete interval training logic and UI (standalone ‚Äî sessions work with intervals)
- Epic 24: Delivers user-facing entry points (standalone ‚Äî Start Screen routes to interval modes)

**Result: Pass ‚Äî each epic delivers complete functionality for its domain.**

### 5. Dependency Validation

**Epic dependencies (linear chain):**
- Epic 21 ‚Üí no dependencies
- Epic 22 ‚Üí depends on 21 (Pitch type)
- Epic 23 ‚Üí depends on 22 (renamed fields, Pitch-based NotePlayer)
- Epic 24 ‚Üí depends on 23 (parameterized sessions)

**Within-epic story dependencies:**
- Epic 21: 21.1 ‚Üí 21.2 ‚Üí 21.3 (each builds on previous types)
- Epic 22: 22.1‚Äì22.4 (independent refactorings, ordered for cleanliness)
- Epic 23: 23.1 ‚Üí 23.2/23.3 ‚Üí 23.4 (data first, then sessions, then UI)
- Epic 24: 24.1 ‚Üí 24.2 (navigation routing, then buttons)

**No forward dependencies detected.**

**Result: Pass.**

---

**Summary: 4 epics, 13 stories, 15 FRs + 1 NFR fully covered, all validation checks pass.**

**All validations complete!** [C] Complete Workflow

### üßë Human (15:27:08)

c

### ü§ñ Assistant (15:27:22)

Workflow complete. The v0.3 epics and stories are saved to `docs/planning-artifacts/epics.md`.

**What was created:**

| Epic | Stories | Focus |
|---|---|---|
| **21: Speak the Language** | 3 stories (21.1‚Äì21.3) | Interval, TuningSystem, Pitch domain types |
| **22: Clean Slate** | 4 stories (22.1‚Äì22.4) | FrequencyCalculation migration, renames, NotePlayer‚ÜíPitch, SoundSourceProvider |
| **23: Intervals Everywhere** | 4 stories (23.1‚Äì23.4) | Data models, session parameterization, strategy, interval label |
| **24: Four Modes, One App** | 2 stories (24.1‚Äì24.2) | NavigationDestination, Start Screen 4 buttons |

**Totals:** 4 epics, 13 stories, 15 FRs (FR53‚ÄìFR67) + NFR14 covered.

Any questions about the epics and stories?

### üßë Human (15:27:27)

commit this

### ü§ñ Assistant (15:27:44)

Committed as `f6198d2`. Working tree clean.

---

[‚Üê Previous (531fe1335b)](531fe1335b.md) | [Index](index.md) | [Next (5f1eb1ec60) ‚Üí](5f1eb1ec60.md)
