---
commit: "5f1eb1ec6033d16f33b27b900c4acac63787648a"
date: "2026-02-28T16:03:56+01:00"
author: "Michael Sch√ºrig <michael@schuerig.de>"
subject: "Add v0.3 interval training architecture amendment and validation fixes"
sessions: ["d5a00b6e-c7f1-4312-abcd-9ec30a6d961e"]
prev: "f6198d2e63.md"
next: "18882145ea.md"
---

[‚Üê Previous (f6198d2e63)](f6198d2e63.md) | [Index](index.md) | [Next (18882145ea) ‚Üí](18882145ea.md)

# Commit 5f1eb1ec60

**Date:** 2026-02-28 16:03:56 UTC+01:00  
**Author:** Michael Sch√ºrig <michael@schuerig.de>

## Commit message

Add v0.3 interval training architecture amendment and validation fixes

Extends the architecture document with interval training (v0.3) covering:
- New domain types (Interval, TuningSystem, Pitch)
- NotePlayer protocol change from Frequency to Pitch
- FrequencyCalculation migration to domain methods
- Unified reference/target naming across all records
- SoundSourceProvider protocol for SettingsScreen decoupling
- Session parameterization with interval sets
- Data model updates with tuningSystem field
- NavigationDestination parameterized with intervals
- Start Screen four-button layout
- MIDI range boundary constraints for transposition
- SwiftData migration strategy (no migration plan needed)

Co-Authored-By: Claude Opus 4.6 <noreply@anthropic.com>

## Changed files

```
docs/planning-artifacts/architecture.md | 601 +++++++++++++++++++++++++++++++-
 1 file changed, 600 insertions(+), 1 deletion(-)
```

## Session `d5a00b6e‚Ä¶`

*2026-02-28 11:03:49 UTC ‚Üí 2026-02-28 15:03:59 UTC*

### üßë Human (11:03:49)

<command-message>bmad-bmm-create-architecture</command-message>
<command-name>/bmad-bmm-create-architecture</command-name>
<command-args>Update the architecture for the changes introduced in v0.3</command-args>

### ü§ñ Assistant (11:03:59)

Let me check for existing architecture documents and discover input documents.

### ü§ñ Assistant (11:04:03)

An existing architecture document was found. Let me read it to check for continuation state.

### ü§ñ Assistant (11:04:07)

The architecture document exists with `stepsCompleted: [1, 2, 3, 4, 5, 6, 7, 8]` and status `amended`. I need to load the continuation step.

### ü§ñ Assistant (11:04:10)

Let me read the full architecture document to understand the current state.

### ü§ñ Assistant (11:04:28)

Now I have a complete picture of the existing architecture document. Let me check what v0.3 changes were introduced in the PRD and UX design.

### ü§ñ Assistant (11:05:57)

Welcome back Michael! I found your Architecture work for Peach.

**Current Progress:**
- Steps completed: 1, 2, 3, 4, 5, 6, 7, 8
- Last step worked on: Step 8
- Status: **amended** (last amended 2026-02-25 for v0.2)
- Input documents loaded: 4 files (PRD, UX Design, Glossary, Brainstorming session)

**Document Sections Found:**
- Project Context Analysis (Requirements Overview, Technical Constraints, Cross-Cutting Concerns)
- Starter Template & Technology Foundation
- Core Architectural Decisions (Data Architecture, App Architecture & State Management, Decision Impact Analysis)
- Implementation Patterns & Consistency Rules (Naming, Project Organization, Test Organization, Error Handling, SwiftUI Patterns, Enforcement Guidelines)
- Project Structure & Boundaries (Directory Structure, Architectural Boundaries, Requirements Mapping, Cross-Cutting Concerns Mapping)
- Architecture Validation Results (Coherence, Coverage, Gap Analysis, Completeness Checklist, Readiness Assessment, Implementation Handoff)
- v0.2 Architecture Amendment ‚Äî Pitch Matching (Renames, PlaybackHandle, PitchMatchingSession, PitchMatchingRecord, Observer Pattern, Profile Protocol Split, DataStore Extension, Note Selection, Updated Structure, Updated Mappings, Implementation Sequence, Validation)

**v0.3 Changes Detected (not yet in architecture):**
The PRD and UX Design have been updated with v0.3 ‚Äî **Interval Training** (15 new FRs: FR53‚ÄìFR67). This introduces:
- Interval domain model (Interval value object, Tuning System abstraction)
- Interval Comparison training (reuses ComparisonScreen with interval parameter)
- Interval Pitch Matching training (reuses PitchMatchingScreen with interval parameter)
- 4-button Start Screen layout (unison + interval modes)
- Fixed Perfect Fifth Up for v0.3 scope

The architecture document needs a **v0.3 amendment** to cover these additions.

**What would you like to do?**

- **[R]** Resume from where we left off (proceed to amend with v0.3)
- **[C]** Continue to next logical step (same as R ‚Äî the next step is the v0.3 amendment)
- **[O]** Overview of all remaining steps
- **[X]** Start over (will overwrite existing work)

### üßë Human (12:44:13)

r

### ü§ñ Assistant (12:44:19)

Let me load the full v0.3 input documents to ground the amendment work.

### ü§ñ Assistant (12:49:24)

Good. I now have all v0.3 input documents loaded. Let me also check the current codebase structure to ground the amendment in reality.

### ü§ñ Assistant (12:51:16)

Excellent. I've loaded all v0.3 input documents and analyzed the current codebase. Let me present my analysis before we start making decisions together.

---

## v0.3 Architecture Amendment ‚Äî Analysis

**Scope:** 15 new FRs (FR53‚ÄìFR67) introducing Interval Training ‚Äî interval-based variants of both Comparison and Pitch Matching.

**The central architectural insight from FR66:** Unison modes ARE interval modes with interval fixed to prime. The PRD and UX spec both say "same underlying sessions, same screens" ‚Äî this points strongly toward **parameterizing existing components** rather than creating parallel ones.

### Decisions We Need to Make

Here's what I see as the key architectural decision areas for v0.3:

**1. Interval & TuningSystem Domain Model (FR53‚ÄìFR55)**
- `Interval` value type (Prime through Octave) ‚Äî enum or struct?
- `TuningSystem` abstraction ‚Äî protocol mapping intervals to cent offsets
- Where these live in the project structure (`Core/` somewhere)

**2. Session Parameterization Strategy (FR57, FR58, FR61, FR62, FR66)**
- FR66 is the key driver: unison = prime case. This means we add an `interval` parameter to existing sessions rather than creating new `IntervalComparisonSession` / `IntervalPitchMatchingSession` classes
- The question: interval as a start parameter (`startTraining(interval:)`) or a configuration property?

**3. Data Model Extension (FR64)**
- Add optional `targetInterval` field to existing `ComparisonRecord` and `PitchMatchingRecord`? Or create new record types?

**4. Note Selection / Strategy Impact (FR57)**
- How interval affects `NextComparisonStrategy` ‚Äî the second note is now at `interval ¬± deviation`, not `unison ¬± deviation`
- For pitch matching: challenge generation changes similarly

**5. Navigation & Start Screen (FR65)**
- How to route four buttons to two screens with different interval parameters
- `NavigationDestination` enum extension

**6. Profile Impact**
- Do interval comparison results feed `PitchDiscriminationProfile`? Or a separate profile?
- Same question for interval pitch matching ‚Üí `PitchMatchingProfile`

---

Want me to walk through these one by one, or do you have a strong leaning on any of them already? I'd suggest starting with **Decision 1 (domain model)** since everything else depends on how we represent intervals and tuning systems.

### üßë Human (12:54:29)

walk through them one by one, start with the domain model

### ü§ñ Assistant (12:55:16)

## Decision 1: Interval & TuningSystem Domain Model

### Interval Value Type (FR53)

FR53 says: *"System represents musical intervals as a value object spanning Prime (unison) through Octave."*

The domain is well-bounded ‚Äî 13 named intervals from prime to octave. I'd propose an **enum**:

```swift
enum Interval: Int, Hashable, Sendable, CaseIterable {
    case prime = 0
    case minorSecond = 1
    case majorSecond = 2
    case minorThird = 3
    case majorThird = 4
    case perfectFourth = 5
    case tritone = 6
    case perfectFifth = 7
    case minorSixth = 8
    case majorSixth = 9
    case minorSeventh = 10
    case majorSeventh = 11
    case octave = 12
    
    /// Semitone count (same as rawValue, but semantically clear)
    var semitones: Int { rawValue }
}
```

**Why enum over struct:** Exhaustive switch, no invalid states, the PRD explicitly bounds Prime‚ÄìOctave. `Int` raw value gives us free `Codable`, `Comparable`, and the semitone count in one shot.

**Direction (up/down):** The PRD mentions "per direction: up/down" as **deferred** beyond v0.3. For v0.3, it's always "up." I'd leave direction out of the type for now ‚Äî the `Interval` represents an interval quality, not a directed leap. The display string "Perfect Fifth Up" is a localization concern. When direction becomes configurable later, we add a direction parameter at the session level.

### TuningSystem Abstraction (FR54‚ÄìFR55)

FR55 requires that adding a new tuning system requires **no changes to interval or training logic**. This calls for a protocol:

```swift
protocol TuningSystem: Sendable {
    /// Cent offset from the root for a given interval
    func centOffset(for interval: Interval) -> Double
}
```

With the initial 12-TET implementation:

```swift
struct EqualTemperament: TuningSystem {
    func centOffset(for interval: Interval) -> Double {
        Double(interval.semitones) * 100.0
    }
}
```

This is trivially simple for 12-TET but the protocol exists so that Just Intonation (3:2 = 701.955 cents for a fifth) or other systems plug in without touching sessions or strategies.

**How it's used:** A session computes the target frequency by taking the reference note's frequency and adding `tuningSystem.centOffset(for: interval)` cents. The existing `FrequencyCalculation.swift` already handles cent-to-Hz conversion, so no new math is needed.

### File Placement

The existing `Core/Audio/` directory holds pitch-related value types (`Frequency`, `Cents`, `MIDINote`). Interval and TuningSystem are musically adjacent. Two options:

- **`Core/Audio/`** ‚Äî keeps related pitch/frequency types together, avoids directory proliferation
- **`Core/Interval/`** ‚Äî separates musical theory concepts from audio engineering

I'm leaning toward `Core/Audio/` since the project convention is minimal directory structure and these types are tightly coupled to existing pitch types. But I could see the argument for a separate directory.

---

What's your take on these three things ‚Äî enum design, tuning system protocol, and file placement?

### üßë Human (13:31:36)

MIDINote.frequency() now needs a second parameter for a Tuning System. Default to EqualTemperament. I'd like to have a method that maps a MIDINote and an Interval to another MIDINote. I'm not sure if it should be on MIDINote or or Interval.

TuningSystem:
* centOffset() is a useful function
* I expect the main usage in practice will be this: given a TuningSystem, a reference pitch, and a MIDINote, calculate the Frequency.
* Can this be an enum? Rationale: Some time in the future we will want to show a picker for the tuning system.

File Placement: put Interval into Core/Audio

Some things I've noticed:

* We're lacking a concept/type for a MIDI note with a cent offset. Possibly the tuning system needs to be included, too. I have no good name for this.
* SoundFontNotePlayer should take an object of this type and should assume that it is valid.
* The tasks of FrequencyCalculation should be handled by the domain classes.
* We're still passing around naked values, e.g. for the reference pitch.
* SettingsScreen still has a dependency on and internal knowledge of SoundFontLibrary. This must be replaced by an implementation-neutral protocol, say SoundSourceProvider.

### ü§ñ Assistant (13:33:08)

Great input. Let me work through each point.

### MIDINote + Interval ‚Üí MIDINote

I'd put this on `MIDINote` ‚Äî it reads most naturally:

```swift
extension MIDINote {
    func transposed(by interval: Interval) -> MIDINote
}
// Usage: MIDINote(60).transposed(by: .perfectFifth) ‚Üí MIDINote(67)
```

"Middle C transposed by a perfect fifth" is how musicians think about it. The MIDINote is the subject, the interval is the operation.

### The "MIDI note with cent offset" type

I'd propose **`Pitch`**. It's the standard music theory term for a specific point in pitch space. Currently "pitch" appears in compound names (`PitchMatching`, `PitchDiscriminationProfile`) but never as a standalone type ‚Äî no collision.

```swift
struct Pitch: Hashable, Sendable {
    let note: MIDINote       // nearest semitone
    let cents: Cents         // offset from that semitone
    
    func frequency(referencePitch: Frequency = .concert440) -> Frequency {
        // note ‚Üí Hz, then apply cent offset
    }
}
```

Then the interval-aware computation chains naturally:

```swift
extension MIDINote {
    /// Nearest MIDI note for the interval (semitone transposition)
    func transposed(by interval: Interval) -> MIDINote
    
    /// Exact pitch for the interval in a given tuning system
    func pitch(at interval: Interval, in tuningSystem: TuningSystem = .equalTemperament) -> Pitch
}
```

For 12-TET, `pitch(at: .perfectFifth)` returns `Pitch(note: 67, cents: 0)`. For Just Intonation, it returns `Pitch(note: 67, cents: ~1.955)` ‚Äî the tuning system deviation.

The tuning system is **not** part of the Pitch type itself. A pitch of "MIDI 67 + 2 cents" is the same pitch regardless of which tuning system produced it. The tuning system is how you *compute* the Pitch from a reference note + interval.

### TuningSystem as enum

Makes sense ‚Äî closed set, future picker support:

```swift
enum TuningSystem: Hashable, Sendable, CaseIterable {
    case equalTemperament
    // Future: case justIntonation, case pythagorean
    
    func centOffset(for interval: Interval) -> Double {
        switch self {
        case .equalTemperament:
            return Double(interval.semitones) * 100.0
        }
    }
}
```

For the "main usage" you described ‚Äî given a TuningSystem, a reference pitch, and a MIDINote, calculate the Frequency ‚Äî that's exactly `Pitch.frequency(referencePitch:)`. The caller first builds the `Pitch` from `referenceNote.pitch(at: interval, in: tuningSystem)`, then calls `.frequency(referencePitch:)`.

### NotePlayer takes Pitch instead of raw frequency

This addresses your SoundFontNotePlayer point directly. Currently NotePlayer takes `Double` Hz values, and SoundFontNotePlayer internally converts Hz ‚Üí MIDI note + pitch bend (its native domain). If we pass `Pitch` instead, the conversion disappears ‚Äî SoundFontNotePlayer works directly with MIDI notes and cent-based pitch bends, which is what it actually does under the hood.

```swift
protocol NotePlayer {
    func play(pitch: Pitch, velocity: MIDIVelocity, amplitudeDB: AmplitudeDB) async throws -> PlaybackHandle
    func play(pitch: Pitch, duration: TimeInterval, velocity: MIDIVelocity, amplitudeDB: AmplitudeDB) async throws
}
```

This also eliminates most of the naked values ‚Äî velocity and amplitude already have domain types (`MIDIVelocity`, `AmplitudeDB`), and now pitch does too.

### FrequencyCalculation ‚Üí domain methods

If `Pitch` has `.frequency(referencePitch:)` and `MIDINote` has `.frequency(referencePitch:tuningSystem:)`, the standalone `FrequencyCalculation.swift` becomes redundant. Its logic migrates into the domain types. The file can be deleted once all call sites are updated.

### Reference pitch as typed value

The `Frequency` type already exists in the codebase. A `Frequency.concert440` static constant makes the default explicit:

```swift
extension Frequency {
    static let concert440 = Frequency(440.0)
}
```

Settings currently stores the reference pitch as a raw value in `@AppStorage`. The `UserSettings` protocol could expose it as `var referencePitch: Frequency`.

### SoundSourceProvider protocol

Agreed ‚Äî SettingsScreen shouldn't know about SoundFontLibrary. A protocol like:

```swift
protocol SoundSourceProvider {
    var availableSources: [SoundSourceID] { get }
    func displayName(for source: SoundSourceID) -> String
}
```

`SoundFontLibrary` conforms to it. SettingsScreen depends on `SoundSourceProvider` via environment, not the concrete type.

---

### Summary of prerequisite refactorings for v0.3

Similar to how v0.2 had prerequisite renames, v0.3 has prerequisite type enrichment:

| Refactoring | Rationale |
|---|---|
| New `Pitch` type (MIDINote + Cents) | Interval training needs to express non-MIDI-grid pitches |
| New `Interval` enum | Core domain concept for v0.3 |
| New `TuningSystem` enum | FR54‚ÄìFR55 |
| `MIDINote.transposed(by:)` and `.pitch(at:in:)` | Maps notes to intervals |
| `NotePlayer` protocol takes `Pitch` | Eliminates Hz ‚Üî MIDI conversion at boundary |
| `FrequencyCalculation.swift` ‚Üí domain methods | Logic belongs on domain types |
| Reference pitch exposed as `Frequency` | Eliminates raw Double |
| `SoundSourceProvider` protocol | Decouples SettingsScreen from SoundFontLibrary |

Does this land right? Anything you'd change before we move to Decision 2 (session parameterization)?

### üßë Human (13:43:09)

This looks about right, although I expect that there will be some fine tuning in the future, to determin where responsibilities go. Especially, Pitch.frequency(referencePitch:) can't be implemented without reference to a TuningSystem. The implementation details of SoundFontNotePlayer are going to become interesting, because it needs to map Pitch + TuningSystem to MIDI note in 12-TET + pitch bend. These implementation details should not spill out, but we should design the interfaces in such a way that they do not make it unnecessarily hard.

### ü§ñ Assistant (13:45:03)

Good point, and it's worth clarifying now so the interfaces stay clean.

### Pitch.frequency() and TuningSystem

Actually, I believe `Pitch.frequency(referencePitch:)` **can** work without a TuningSystem ‚Äî because `Pitch` is a *resolved* representation. By the time you have a `Pitch(note: MIDINote(67), cents: Cents(1.955))`, the TuningSystem has already done its job (it computed those 1.955 cents when building the Pitch from a reference note + interval). The frequency formula is just:

```
referencePitch √ó 2^((note - 69 + cents/100) / 12)
```

The TuningSystem is consumed at **Pitch construction** (`referenceNote.pitch(at: .perfectFifth, in: .justIntonation)`), not at frequency conversion. But I agree we should stay alert to where this breaks down as we get into implementation detail.

### SoundFontNotePlayer design principle

Noted as a design principle for all interfaces in this amendment: **interfaces must not assume the implementation's internal representation.** SoundFontNotePlayer maps `Pitch` to MIDI noteOn + pitch bend internally ‚Äî that's its business. The `NotePlayer` protocol gives it a `Pitch` and doesn't care how it gets played. The `Pitch` type is friendly to MIDI-based implementations (it IS a MIDI note + cent offset), but that's by design, not by coupling.

---

## Decision 2: Session Parameterization

FR66 is the driver: *"Unison comparison and unison pitch matching behave identically to their interval variants with the interval fixed to prime."*

This means we **parameterize existing sessions**, not create new ones. The question is how.

### Proposed approach: interval as a start parameter

Currently the app has one `ComparisonSession` instance and one `PitchMatchingSession` instance wired in PeachApp. I'd keep that ‚Äî the interval is a per-training-run parameter:

```swift
// Current
comparisonSession.startTraining()

// v0.3
comparisonSession.startTraining(interval: .prime)              // "Comparison" button
comparisonSession.startTraining(interval: .perfectFifth)       // "Interval Comparison" button
```

Same for PitchMatchingSession:

```swift
pitchMatchingSession.startPitchMatching(interval: .prime)
pitchMatchingSession.startPitchMatching(interval: .perfectFifth)
```

The session stores the interval for the duration of the training run. Default is `.prime`, so existing call sites don't change unless they want intervals.

**TuningSystem:** For v0.3 (single fixed tuning system), the TuningSystem could be hardcoded to `.equalTemperament` inside the session. When tuning system selection is added later, it becomes another parameter (from settings or start call). I'd pass it as a start parameter too, defaulting to `.equalTemperament`:

```swift
comparisonSession.startTraining(interval: .perfectFifth, tuningSystem: .equalTemperament)
```

### Impact on NextComparisonStrategy

Currently the strategy returns a `Comparison` with `note1`, `note2` (same MIDI note in unison), and `note2CentOffset`. For intervals, note2 becomes the interval's MIDI note:

- **Unison:** note1 = C4(60), note2 = C4(60), offset = +15 cents
- **Interval (P5):** note1 = C4(60), note2 = G4(67), offset = +15 cents

The offset semantics stay the same ‚Äî it's always "deviation from where note2 should be." The strategy just needs the interval to compute note2:

```swift
protocol NextComparisonStrategy {
    func nextComparison(
        profile: PitchDiscriminationProfile,
        settings: UserSettings,
        interval: Interval,
        tuningSystem: TuningSystem
    ) -> Comparison
}
```

The strategy selects a reference note and difficulty (cent deviation) as before, then computes note2 using `note1.transposed(by: interval)`. For `.prime`, note2 = note1 ‚Äî identical to current behavior.

### Impact on PitchMatchingSession challenge generation

Currently `PitchMatchingSession` generates challenges internally (random note + random offset). For intervals, the challenge becomes:

- Reference note: random MIDI note in range (same as now)
- Target pitch: `referenceNote.pitch(at: interval, in: tuningSystem)`
- Initial offset: random ¬±100 cents from the target pitch (same range as now, but offset from interval pitch rather than unison)

The `PitchMatchingChallenge` type gains an interval field:

```swift
struct PitchMatchingChallenge {
    let referenceNote: MIDINote
    let targetInterval: Interval
    let initialCentOffset: Double  // offset from correct interval pitch
}
```

### Observable state: interval indicator for the UI

Both sessions need to expose the current interval so the screen can conditionally show the target interval label:

```swift
// On ComparisonSession / PitchMatchingSession
private(set) var currentInterval: Interval = .prime

var isIntervalMode: Bool { currentInterval != .prime }
```

The screen checks `isIntervalMode` to show/hide the target interval label ‚Äî matching the UX spec ("Hidden in unison mode, visible in interval mode").

---

### What stays unchanged

- One `ComparisonSession` instance, one `PitchMatchingSession` instance in PeachApp
- `activeSession` tracking (only one active at a time)
- Observer pattern ‚Äî observers are notified the same way
- Feedback timing (0.4s), haptic behavior, interruption handling ‚Äî all identical

---

Does this session parameterization approach work for you? Or would you prefer separate session instances per mode (4 total)?

### üßë Human (14:21:42)

startTraining() and startPitchMatching() should actually both take a (non-empty) set of intervals.

### ü§ñ Assistant (14:22:06)

That's a smart generalization. It handles everything cleanly:

- Unison: `[.prime]`
- v0.3 interval: `[.perfectFifth]`
- Future multi-interval rotation: `[.perfectFourth, .perfectFifth, .majorThird]`

The session stores the set and picks one interval per exercise (random selection from the set). The `currentInterval` observable property updates each round so the UI shows the correct label.

```swift
comparisonSession.startTraining(
    intervals: [.prime],
    tuningSystem: .equalTemperament
)

comparisonSession.startTraining(
    intervals: [.perfectFifth],
    tuningSystem: .equalTemperament
)
```

The strategy still receives a single interval per call ‚Äî the session does the selection, then passes it:

```swift
let interval = intervals.randomElement()!  // safe ‚Äî set is non-empty
let comparison = strategy.nextComparison(
    profile: profile, settings: settings,
    interval: interval, tuningSystem: tuningSystem
)
```

For the non-empty guarantee ‚Äî a `Set<Interval>` with a precondition in `startTraining()` seems proportionate. No need for a custom `NonEmptySet` type at this scope.

This also means the `PitchMatchingChallenge` and `Comparison` types don't need to change for multi-interval ‚Äî the session picks one, the rest of the pipeline handles a single interval.

---

Shall we move to **Decision 3: Data Model Extension** ‚Äî how interval results get recorded?

### üßë Human (14:23:06)

yes

### ü§ñ Assistant (14:23:50)

## Decision 3: Data Model Extension

FR64 requires: *"System records interval pitch matching results: reference note, target interval, user's final pitch, error in cents relative to the correct interval pitch, timestamp."* The PRD similarly specifies interval context for comparison records.

### Current records

```
ComparisonRecord:      note1, note2, note2CentOffset, isCorrect, timestamp
PitchMatchingRecord:   referenceNote, initialCentOffset, userCentError, timestamp
```

### The key insight: existing fields already work for intervals

For comparison, `note2` is already a separate MIDI note from `note1`. In unison, note2 = note1. For intervals, note2 = note1.transposed(by: interval). The cent offset is always "deviation from where note2 should be." No field semantics change ‚Äî we just need to record **which interval was being tested**.

Same for pitch matching ‚Äî `initialCentOffset` and `userCentError` are already relative to "the target pitch." For unison, that target is the reference note. For intervals, it's the interval pitch. The semantics hold. We just need to record the interval.

### Proposed: add `targetInterval` to existing records

Since FR66 says unison = prime case, a single record type per mode is most consistent:

```swift
// ComparisonRecord gains:
var targetInterval: Interval = .prime

// PitchMatchingRecord gains:
var targetInterval: Interval = .prime
```

Non-optional with a default of `.prime`. SwiftData lightweight migration handles adding a property with a default value ‚Äî existing rows get `.prime` automatically. No data loss, no separate migration code.

`Interval` with `Int` raw value is `Codable` for free, so SwiftData stores it as an integer.

### Should we also store `tuningSystem`?

If someone later switches from 12-TET to Just Intonation, "5 cents off a perfect fifth" means different things ‚Äî 700 cents in 12-TET vs. 701.955 cents in JI. Without the tuning system, historical records are ambiguous.

Two options:

- **Store it now** ‚Äî `var tuningSystem: TuningSystem = .equalTemperament` on both records. Future-proof, small cost.
- **Defer** ‚Äî v0.3 only has one tuning system. Add the field when a second system is introduced. Existing records are retroactively 12-TET by convention.

I'd lean toward storing it now ‚Äî it's one field, and it eliminates ambiguity permanently. But it's defensible either way.

### What this means for profiles

If all comparison records (unison + interval) share one record type, `PerceptualProfile` receives all of them at startup. The question is: should interval comparison results feed the same `PitchDiscriminationProfile`? This bleeds into Decision 6 (profile impact), but the data model choice enables either path ‚Äî we can filter by `targetInterval` when aggregating.

---

What's your call on storing `tuningSystem` now vs. deferring? And any concerns about the single-record-type approach?

### üßë Human (14:41:27)

"we just need to record which interval was being tested" in the PitchMatchingRecord we indeed need to do this. In the ComparisonRecord, the interval is implied by the two notes. Interval should have a static method that returns the interval for two MIDINotes; and throw if it is out of range.

For PitchMatchingRecord, we should consider storing the target note instead of the target interval. The interval, then, is implied by the two notes.

This may be a chance to unify naming and concepts: In all our trainings, so far, we have a reference note and a target note. We call them by a variety of names, but abstractly, it's just reference and target. Maybe we need another round of refactorings before we can get started on the trainings with intervals.

Store the tuning system now.

When it comes to profiles, I'm afraid, they are a bit useless right now. When using the app, I look at the result of the latest comparison or challenge, but the profile visualization and statistics are of no use to me. Nevertheless, I want to record all relevant data now, so that we have a solid base of data for when we get to work on the profile again.

### ü§ñ Assistant (14:42:11)

Excellent observations. This is cleaner than what I proposed.

### Interval derivation from two notes

```swift
extension Interval {
    /// Returns the interval between two MIDI notes. Throws if out of Prime‚ÄìOctave range.
    static func between(_ reference: MIDINote, _ target: MIDINote) throws -> Interval
}
```

No redundant storage. The interval is always derivable from the concrete note data.

### Unified reference/target naming

You're right ‚Äî across all training modes, the abstract concept is always the same:

| Mode | Reference note | Target note |
|---|---|---|
| Unison comparison | Note played first | Same MIDI note (¬± cent deviation) |
| Interval comparison | Note played first | Interval MIDI note (¬± cent deviation) |
| Unison pitch matching | Note played first | Same MIDI note (user tunes to it) |
| Interval pitch matching | Note played first | Interval MIDI note (user tunes to it) |

### Prerequisite renames (v0.3)

| Current | New | Where |
|---|---|---|
| `note1` | `referenceNote` | `ComparisonRecord`, `Comparison` value type |
| `note2` | `targetNote` | `ComparisonRecord`, `Comparison` value type |
| `note2CentOffset` | `centDeviation` (or similar) | `ComparisonRecord`, `Comparison` value type |

Plus all references in `ComparisonSession`, `NextComparisonStrategy`, `ComparisonObserver`, tests, and project-context.md.

### Updated record models

**ComparisonRecord:**
```swift
var referenceNote: Int          // was note1
var targetNote: Int             // was note2
var centDeviation: Double       // was note2CentOffset
var isCorrect: Bool
var timestamp: Date
var tuningSystem: TuningSystem = .equalTemperament  // NEW
```

Interval derived: `try Interval.between(MIDINote(referenceNote), MIDINote(targetNote))`

**PitchMatchingRecord:**
```swift
var referenceNote: Int
var targetNote: Int             // NEW ‚Äî what the user was trying to match
var initialCentOffset: Double   // offset from target pitch
var userCentError: Double       // final error from target pitch
var timestamp: Date
var tuningSystem: TuningSystem = .equalTemperament  // NEW
```

For existing unison pitch matching data: migration sets `targetNote = referenceNote` (unison target equals reference).

### Profile: record everything, defer computation changes

Understood. The priority is a solid data foundation. Profile aggregation and visualization improvements are a separate effort. For v0.3, the records capture all context (reference, target, tuning system), and profile computation continues as-is ‚Äî it just receives richer data.

---

Three decisions remain: **strategy impact** (partly covered ‚Äî strategy receives interval + tuning system), **navigation & start screen**, and **profile**. Strategy and profile are mostly settled from the discussion so far. Shall I walk through **Decision 4 (navigation & start screen)** next, or do you want to revisit anything on the data model first?

### üßë Human (14:45:03)

Change note2CentOffset into centOffset (not centDeviation)

Continue

### ü§ñ Assistant (14:46:01)

Noted ‚Äî `centOffset`, not `centDeviation`.

## Decision 4: Strategy / Note Selection Impact

This is mostly settled from our earlier discussion. Let me confirm the shape:

**NextComparisonStrategy** receives interval + tuning system:

```swift
protocol NextComparisonStrategy {
    func nextComparison(
        profile: PitchDiscriminationProfile,
        settings: UserSettings,
        interval: Interval,
        tuningSystem: TuningSystem
    ) -> Comparison
}
```

The strategy selects a reference note and difficulty (cent offset magnitude) as before, then sets `targetNote = referenceNote.transposed(by: interval)`. For `.prime`, targetNote = referenceNote ‚Äî identical to current behavior.

**PitchMatchingSession** challenge generation remains internal (random selection, no strategy protocol). It now picks a reference note and computes the target from the selected interval:

```swift
let interval = intervals.randomElement()!
let challenge = PitchMatchingChallenge(
    referenceNote: randomNoteInRange,
    targetNote: randomNoteInRange.transposed(by: interval),
    initialCentOffset: randomOffset
)
```

Nothing surprising here. The interval generalizes cleanly because "pick a note, offset from target" is the same pattern regardless of what the target is.

---

## Decision 5: Navigation & Start Screen

### NavigationDestination

Currently `.training` and `.pitchMatching` are bare cases. Two options:

**Option A ‚Äî Parameterize existing cases:**

```swift
enum NavigationDestination: Hashable {
    case comparison(intervals: Set<Interval>)   // renamed from .training
    case pitchMatching(intervals: Set<Interval>)
    case settings
    case profile
}
```

**Option B ‚Äî Add separate interval cases:**

```swift
case training
case intervalComparison
case pitchMatching
case intervalPitchMatching
```

I'd go with **Option A**. It reflects FR66 ‚Äî there's no separate "interval mode," just a different interval set. And `.training` ‚Üí `.comparison` aligns with the v0.2 rename that already happened for sessions and screens but was missed on the navigation enum.

### Start Screen routing

Four buttons, same two screens, different interval sets:

```swift
NavigationLink(value: .comparison(intervals: [.prime]))       { Text("Comparison") }
NavigationLink(value: .pitchMatching(intervals: [.prime]))    { Text("Pitch Matching") }
// visual separator
NavigationLink(value: .comparison(intervals: [.perfectFifth]))    { Text("Interval Comparison") }
NavigationLink(value: .pitchMatching(intervals: [.perfectFifth])) { Text("Interval Pitch Matching") }
```

The destination handler passes intervals to the screen, which passes them to the session's start method.

### Tuning system

Not part of the navigation destination ‚Äî it's a training configuration concern. For v0.3, the session defaults to `.equalTemperament`. When tuning system selection is added later, it comes from settings.

### Prerequisite rename

`.training` ‚Üí `.comparison` in NavigationDestination, ContentView, StartScreen, and any references.

---

## Decision 6: Profile Impact

Per your direction: **record everything, defer computation changes.**

- Interval comparison results flow through the same `ComparisonObserver` path
- Interval pitch matching results flow through the same `PitchMatchingObserver` path
- Profiles receive all data regardless of interval ‚Äî no filtering, no interval-aware aggregation
- All records carry full context (referenceNote, targetNote, tuningSystem) so future profile work has solid data to work with
- No changes to `PitchDiscriminationProfile` or `PitchMatchingProfile` protocols or computation

---

That covers all six decisions. Shall I draft the full v0.3 architecture amendment into the document? Or is there anything you want to adjust first?

### üßë Human (14:48:17)

5: Use Option A.

Yes, draft the amendment.

### ü§ñ Assistant (14:48:26)

Let me check the exact end of the current architecture document to append correctly.

### ü§ñ Assistant (14:48:30)

Good. Now let me also read some key source files to ensure the amendment references actual current code patterns correctly.

### ü§ñ Assistant (14:48:53)

Good. I now have full context. Let me draft the amendment.

### ü§ñ Assistant (14:49:00)

Now let me append the full v0.3 amendment.

### ü§ñ Assistant (14:51:33)

The v0.3 amendment has been drafted. Let me verify it reads correctly at the boundaries.

### ü§ñ Assistant (14:51:46)

The amendment is complete and cleanly appended. Here's a summary of what was written:

**v0.3 Architecture Amendment** (lines 912‚Äì1493, ~580 lines) covers:

- **Central design principle** ‚Äî FR66: unison is the prime case
- **Prerequisite refactorings** (A‚ÄìE):
  - New domain types: `Interval` enum, `TuningSystem` enum, `Pitch` struct
  - `NotePlayer` protocol takes `Pitch` instead of `Frequency`
  - `FrequencyCalculation.swift` ‚Üí domain methods (then deleted)
  - Unified reference/target naming across all records and value types
  - `SoundSourceProvider` protocol decoupling SettingsScreen from SoundFontLibrary
- **Session parameterization** ‚Äî `startTraining(intervals:tuningSystem:)` with `Set<Interval>`
- **Strategy update** ‚Äî receives interval + tuningSystem per comparison
- **Data model** ‚Äî `centOffset` rename, `targetNote` + `tuningSystem` fields on records
- **Navigation** ‚Äî parameterized `.comparison(intervals:)` / `.pitchMatching(intervals:)`
- **Profile** ‚Äî record everything, defer computation changes
- **Updated project structure, FR mapping, cross-cutting concerns, implementation sequence, validation**

Ready for your review. Anything you'd like adjusted?

### üßë Human (14:52:36)

let's validate this amendment

### ü§ñ Assistant (14:57:53)

The validation is thorough. Here's the summary:

## Validation Results

| Check | Verdict |
|---|---|
| Requirements Coverage (FR53‚ÄìFR67 + NFR) | **PASS** |
| Coherence with Existing Architecture | **PASS** |
| Coherence with Project Context | **PASS** |
| Codebase Accuracy | **PASS with warnings** |
| Internal Consistency | **PASS with warning** |
| Completeness | **WARNING** |
| Implementation Risks | **1 HIGH, 2 MEDIUM, 2 LOW** |

## Issues to Address

**Must-fix (4 items):**

1. **`CompletedComparison` missing `tuningSystem`** ‚Äî The observer flow can't persist `tuningSystem` to `ComparisonRecord` without it. `CompletedPitchMatching` correctly has it, but `CompletedComparison` was missed.

2. **SwiftData property renames will lose data** ‚Äî Renaming `note1`‚Üí`referenceNote`, `note2`‚Üí`targetNote`, `note2CentOffset`‚Üí`centOffset` is treated as "delete old + add new" by SwiftData. Options: (a) explicit `SchemaMigrationPlan`, (b) keep internal SwiftData property names unchanged and map at the domain boundary, or (c) add new fields alongside old, migrate, then remove.

3. **MIDI range overflow on interval transposition** ‚Äî `MIDINote(121).transposed(by: .perfectFifth)` ‚Üí MIDINote(128) ‚Üí precondition crash. The strategy must constrain the reference note range to `noteRangeMin...(noteRangeMax - interval.semitones)`.

4. **`PitchMatchingRecord.targetNote` migration** ‚Äî Setting `targetNote = referenceNote` for existing rows can't be done with a simple default value. Needs a `SchemaMigrationPlan` or post-load fixup.

**Should-fix (3 items):**

5. **`PlaybackHandle.adjustFrequency` ‚Äî stays `Frequency` or changes to `Pitch`?** The amendment is silent. Keeping it as `Frequency` is defensible (low-level handle operation), but should be explicitly stated.

6. **Rename table conflates `centDifference` (Comparison) with `note2CentOffset` (ComparisonRecord)** ‚Äî They're different current names mapping to the same new name `centOffset`. Should be separate rows.

7. **`SF2PresetParser.swift` missing from v0.3 structure listing** ‚Äî minor documentation gap.

---

Shall I fix all 7 items in the document now?

### üßë Human (15:00:43)

Fix all issues. However, in issue 2, data loss is really not a problem. I'm the only user, so far, and I don't mind losing the data.

### ü§ñ Assistant (15:01:10)

Now let me read the remaining sections to locate all text that needs fixing.

### ü§ñ Assistant (15:01:17)

Now let me read the project structure section and cross-cutting concerns to locate `SF2PresetParser` gap and the strategy section.

### ü§ñ Assistant (15:01:31)

Good ‚Äî that simplifies the migration story. Let me apply all fixes. (Note: `SF2PresetParser.swift` is actually already listed at line 1342, so that was a false positive from the validator.)

**Fix 1:** Add `tuningSystem` to `CompletedComparison`

### ü§ñ Assistant (15:01:38)

**Fix 2 & 4:** Simplify SwiftData migration ‚Äî data loss is acceptable.

### ü§ñ Assistant (15:01:53)

**Fix 3:** MIDI range boundary checking for interval transposition.

### ü§ñ Assistant (15:02:04)

**Fix 5:** Explicitly state `PlaybackHandle.adjustFrequency` stays as `Frequency`.

### ü§ñ Assistant (15:02:13)

**Fix 6:** Fix the rename table to list `centDifference` (Comparison) separately from `note2CentOffset` (ComparisonRecord).

### ü§ñ Assistant (15:02:20)

All 6 fixes applied. Let me verify the document is consistent by checking the final line count and the fixed sections.

### ü§ñ Assistant (15:02:30)

All fixes are in place. Here's what was addressed:

| Issue | Fix |
|---|---|
| 1. `CompletedComparison` missing `tuningSystem` | Added explicit updated struct with `tuningSystem: TuningSystem` field and note about `ComparisonSession` populating it |
| 2. SwiftData property rename data loss | Replaced migration hedging with clear statement: no production users, data loss acceptable, no `SchemaMigrationPlan` needed |
| 3. MIDI range overflow on transposition | Added boundary constraint: strategy must limit reference note range to `noteRangeMax - interval.semitones`; same for `PitchMatchingSession` |
| 4. `PitchMatchingRecord.targetNote` migration | Same approach as #2 ‚Äî schema change, data loss acceptable |
| 5. `PlaybackHandle.adjustFrequency` unspecified | Explicitly stated it stays as `Frequency`; session converts `Pitch` ‚Üí `Frequency` before passing to handle |
| 6. Rename table conflation | Split into separate rows: `note2CentOffset` ‚Üí `centOffset` (ComparisonRecord) and `centDifference` ‚Üí `centOffset` (Comparison) |
| 7. `SF2PresetParser.swift` missing | False positive ‚Äî already listed at line 1342 |

The amendment is now at 1509 lines total. Ready for your review.

### üßë Human (15:03:43)

commit this

### ü§ñ Assistant (15:03:59)

Committed as `5f1eb1e`. Clean working tree, 600 lines added to the architecture document.

---

[‚Üê Previous (f6198d2e63)](f6198d2e63.md) | [Index](index.md) | [Next (18882145ea) ‚Üí](18882145ea.md)
