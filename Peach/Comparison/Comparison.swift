import Foundation

/// Represents a single pitch comparison challenge for training
///
/// A comparison presents two notes to the user: one reference note and one offset
/// by a cent difference (higher or lower). The user must identify the direction.
///
/// Comparisons are generated by `AdaptiveNoteStrategy` (via `NextComparisonStrategy` protocol)
/// based on the user's `PerceptualProfile` and `TrainingSettings`.
struct Comparison {
    // REVIEW: MIDI notes should not be raw Int values. We need a proper type for them that ensures that MIDI notes are always within range. Among other things, this would remove the necessity of a lot or parameter checking in methods. The same goes for MIDI velocity. Both should become Value Objects. See https://www.hackingwithswift.com/articles/188/improving-your-swift-code-using-value-objects
    
    /// First note as MIDI number (0-127)
    let note1: Int

    /// Second note as MIDI number (0-127, same as note1 for placeholder)
    let note2: Int

    // REVIEW: It makes no sense to make this positive by convention and then having to check that the convention is upheld. Then effectively introduce a sign with isSecondNoteHigher. centDifference should be signed and isSecondNoteHigher could become a computed property. Cents should become a Value Object.
    
    /// Cent difference applied to note2 (always positive magnitude)
    /// Note: This is converted to signed centOffset in PerceptualProfile based on direction
    let centDifference: Double

    /// Whether the second note is higher than the first
    let isSecondNoteHigher: Bool

    /// Calculates the frequency for note1 using configurable reference pitch
    ///
    /// Uses FrequencyCalculation utility with the reference pitch from Settings.
    ///
    /// - Parameter referencePitch: The reference pitch in Hz (default: 440.0 for A4)
    /// - Returns: Frequency in Hz for the first note
    /// - Throws: AudioError.invalidFrequency if calculation fails (should never happen with valid MIDI)
    func note1Frequency(referencePitch: Double = 440.0) throws -> Double {
        return try FrequencyCalculation.frequency(midiNote: note1, referencePitch: referencePitch)
    }

    /// Calculates the frequency for note2 with cent offset applied
    ///
    /// Applies the cent difference in the direction specified by isSecondNoteHigher:
    /// - If second note is higher: adds centDifference
    /// - If second note is lower: subtracts centDifference
    ///
    /// - Parameter referencePitch: The reference pitch in Hz (default: 440.0 for A4)
    /// - Returns: Frequency in Hz for the second note
    /// - Throws: AudioError.invalidFrequency if calculation fails
    func note2Frequency(referencePitch: Double = 440.0) throws -> Double {
        let cents = isSecondNoteHigher ? centDifference : -centDifference
        return try FrequencyCalculation.frequency(midiNote: note2, cents: cents, referencePitch: referencePitch)
    }

    /// Validates if the user's answer matches the correct comparison
    ///
    /// - Parameter userAnswerHigher: True if user answered "higher", false if "lower"
    /// - Returns: True if the user's answer matches isSecondNoteHigher
    func isCorrect(userAnswerHigher: Bool) -> Bool {
        return userAnswerHigher == isSecondNoteHigher
    }
}

/// Represents a completed comparison with the user's answer
///
/// Bundles together a comparison and the user's response for recording and analysis.
/// This eliminates redundant parameters when passing comparison results to observers.
struct CompletedComparison {
    /// The comparison that was presented
    let comparison: Comparison

    /// Whether the user answered "higher" (true) or "lower" (false)
    let userAnsweredHigher: Bool

    /// Whether the user's answer was correct (computed property)
    var isCorrect: Bool {
        comparison.isCorrect(userAnswerHigher: userAnsweredHigher)
    }

    /// Timestamp when the comparison was completed
    let timestamp: Date

    /// Creates a completed comparison
    ///
    /// - Parameters:
    ///   - comparison: The comparison that was presented
    ///   - userAnsweredHigher: Whether the user answered "higher"
    ///   - timestamp: When the comparison was completed (defaults to now)
    init(comparison: Comparison, userAnsweredHigher: Bool, timestamp: Date = Date()) {
        self.comparison = comparison
        self.userAnsweredHigher = userAnsweredHigher
        self.timestamp = timestamp
    }
}
